<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vulkan-Hpp: vulkan_raii.hpp: a programming guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vulkan-Hpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_vk_raii_ProgrammingGuide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="vulkan__raii_8hpp.html">vulkan_raii.hpp</a>: a programming guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md69"></a>
Introduction</h1>
<p><a class="el" href="vulkan__raii_8hpp.html">vulkan_raii.hpp</a> is a C++ layer on top of <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> that follows the RAII-principle (RAII: Resource Acquisition Is Initialization, see <a href="https://en.cppreference.com/w/cpp/language/raii#:~:text=Resource%20Acquisition%20Is%20Initialization%20or,in%20limited%20supply">https://en.cppreference.com/w/cpp/language/raii#:~:text=Resource%20Acquisition%20Is%20Initialization%20or,in%20limited%20supply</a>). This header-only library uses all the enums and structure wrappers from <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> and provides a new set of wrapper classes for the Vulkan handle types. Instead of creating Vulkan handles with vk*Allocate or vk*Create a constructor of the corresponding Vulkan handle wrapper class is used. And instead of destroying Vulkan handles with vk*Free or vk*Destroy, the destructor of that handle class is called.</p>
<h1><a class="anchor" id="autotoc_md70"></a>
General Usage</h1>
<p>As a simple example, instead of creating a <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code></p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::Device, given a vk::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1Device.html">vk::Device</a> device = physicalDevice.createDevice( deviceCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1Device_html"><div class="ttname"><a href="classvk_1_1Device.html">vk::Device</a></div><div class="ttdef"><b>Definition:</b> vulkan_handles.hpp:8782</div></div>
</div><!-- fragment --><p>and destroying it at some point</p>
<div class="fragment"><div class="line"><span class="comment">// destroy a vk::Device</span></div>
<div class="line">device.<a class="code" href="classvk_1_1Device.html#a2372fd6402f0935dde6270a37ffa79b1">destroy</a>();</div>
<div class="ttc" id="aclassvk_1_1Device_html_a2372fd6402f0935dde6270a37ffa79b1"><div class="ttname"><a href="classvk_1_1Device.html#a2372fd6402f0935dde6270a37ffa79b1">vk::Device::destroy</a></div><div class="ttdeci">void destroy(const vk::AllocationCallbacks *pAllocator, Dispatch const &amp;d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT) const VULKAN_HPP_NOEXCEPT</div></div>
</div><!-- fragment --><p>you would create a <code><a class="el" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a></code></p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Device, given a vk::raii::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a> device( physicalDevice, deviceCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Device_html"><div class="ttname"><a href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:3511</div></div>
</div><!-- fragment --><p>That <code><a class="el" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a></code> is automatically destroyed, when its scope is left.</p>
<p>Alternatively, you can use a creation function to create a <code><a class="el" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Device, given a vk::raii::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a> device = physicalDevice.createDevice( deviceCreateInfo );</div>
</div><!-- fragment --><p>Finally, if you have defined <code>VULKAN_HPP_NO_EXCPETIONS</code> and compile for at least C++23, the constructors as described above are not available (they would potentially throw an exception which is not allowed then) but you have to use the construction functions. Those functions then do not return the created object, but a <code>std::expected&lt;vk::raii::Object, <a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">vk::Result</a>&gt;</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Device, given a vk::raii::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo</span></div>
<div class="line"><span class="comment">// when VULKAN_HPP_NO_EXCPETIONS is defined and your using at least C++23</span></div>
<div class="line"><span class="keyword">auto</span> deviceExpected = physicalDevice.createDevice( deviceCreateInfo );</div>
<div class="line"><span class="keywordflow">if</span> ( deviceExpected.has_value() )</div>
<div class="line">{</div>
<div class="line">    device = std::move( *deviceExpected );</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the code snippets in this text, I will consistently use the constructor-approach.</p>
<p>Other than the <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code>, you can assign the <code><a class="el" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a></code> to a smart pointer:</p>
<div class="fragment"><div class="line"><span class="comment">// create a smart-pointer to a vk::raii::Device, given a smart-pointer to a vk::raii::PhysicalDevice pPhysicalDevice and a vk::DeviceCreateInfo deviceCreateInfo</span></div>
<div class="line">std::unique_ptr&lt;vk::raii::Device&gt; pDevice;</div>
<div class="line">pDevice = std::make_unique&lt;vk::raii::Device&gt;( *pPhysicalDevice, deviceCreateInfo );</div>
</div><!-- fragment --><p>Note that the <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> objects own the actual Vulkan resource. Therefore, all <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> objects that own destructable resources are just movable, but not copyable. Therefore, a few <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> objects, like <a class="el" href="classvk_1_1raii_1_1PhysicalDevice.html">vk::raii::PhysicalDevice</a> are copyable as well.</p>
<p>For simplicity, in the rest of this document a <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> object is always directly instantiated on the stack. Obviously, that's not essential. You could assign them as well to a std::unique_ptr, a std::shared_ptr, or any other smart pointer or object managing data structure. And you can even assign them to a dumb pointer by using the new operator.</p>
<p>Similar to a <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code>, a <code><a class="el" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a></code> provides the functions related to that class. But other than the <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code>, you don't need to provide a device-specific dispatcher to those functions to get multi-device functionality. That's already managed by the <code><a class="el" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a></code>.</p>
<p>That is, calling a device-related function is identical for both cases:</p>
<div class="fragment"><div class="line"><span class="comment">// call waitIdle from a vk::Device</span></div>
<div class="line">device.<a class="code" href="classvk_1_1raii_1_1Device.html#a35376623b4ec982c1d4ed7e451ac6345">waitIdle</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// call waitIdle from a vk::raii::Device</span></div>
<div class="line">device.<a class="code" href="classvk_1_1raii_1_1Device.html#a35376623b4ec982c1d4ed7e451ac6345">waitIdle</a>();</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Device_html_a35376623b4ec982c1d4ed7e451ac6345"><div class="ttname"><a href="classvk_1_1raii_1_1Device.html#a35376623b4ec982c1d4ed7e451ac6345">vk::raii::Device::waitIdle</a></div><div class="ttdeci">void waitIdle() const</div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:12213</div></div>
</div><!-- fragment --><p><a class="el" href="namespacevk_1_1raii.html">vk::raii</a> goes one step further. In the vk namespace, most of the functions are members of <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code>. In the <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> namespace functions strongly related to a non-dispatchable handle are members of the corresponding vi::raii object. For example, to bind memory to a buffer, in vk namespace you write</p>
<div class="fragment"><div class="line"><span class="comment">// bind vk::DeviceMemory memory to a vk::Buffer buffer, given vk::DeviceSize memoryOffset</span></div>
<div class="line">device.bindBufferMemory( buffer, memory, memoryOffset );</div>
</div><!-- fragment --><p>In <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> namespace you write</p>
<div class="fragment"><div class="line"><span class="comment">// bind vk::raii::DeviceMemory memory to a vk::raii::Buffer buffer, given vk::DeviceSize memoryOffset</span></div>
<div class="line">buffer.bindMemory( *memory, memoryOffset );</div>
</div><!-- fragment --><p>Note that <code><a class="el" href="classvk_1_1raii_1_1Buffer.html#aa82e783acb2bacbab3478acd8fb910a4">vk::raii::Buffer::bindMemory()</a></code>takes a <code><a class="el" href="classvk_1_1DeviceMemory.html">vk::DeviceMemory</a></code> as its first argument, not a <code><a class="el" href="classvk_1_1raii_1_1DeviceMemory.html">vk::raii::DeviceMemory</a></code>. From a <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> object you get to the corresponding vk object by just dereferencing the <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> object.</p>
<h1><a class="anchor" id="autotoc_md71"></a>
First Steps</h1>
<h2><a class="anchor" id="autotoc_md72"></a>
00 Create a vk::raii::Context</h2>
<p>The very first step when using classes from the <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> namespace is to instantiate a <code><a class="el" href="classvk_1_1raii_1_1Context.html">vk::raii::Context</a></code>. This class has no counterpart in either the vk namespace or the pure C-API of Vulkan. It is the handle to the few functions that are not bound to a <code>VkInstance</code> or a <code>VkDevice</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// instantiate a vk::raii::Context</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Context.html">vk::raii::Context</a> context;</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Context_html"><div class="ttname"><a href="classvk_1_1raii_1_1Context.html">vk::raii::Context</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:2696</div></div>
</div><!-- fragment --><p>To use any of those "global" functions, your code would look like that:</p>
<div class="fragment"><div class="line"><span class="comment">// get the API version, using that context</span></div>
<div class="line">uint32_t apiVersion = context.<a class="code" href="classvk_1_1raii_1_1Context.html#a406fa5a18567564eaf52434438e79f41">enumerateInstanceVersion</a>();</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Context_html_a406fa5a18567564eaf52434438e79f41"><div class="ttname"><a href="classvk_1_1raii_1_1Context.html#a406fa5a18567564eaf52434438e79f41">vk::raii::Context::enumerateInstanceVersion</a></div><div class="ttdeci">VULKAN_HPP_NODISCARD uint32_t enumerateInstanceVersion() const</div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:13751</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md73"></a>
01 Create a vk::raii::Instance</h2>
<p>To pass that information on to a <code><a class="el" href="classvk_1_1raii_1_1Instance.html">vk::raii::Instance</a></code>, its constructor gets a reference to that <code><a class="el" href="classvk_1_1raii_1_1Context.html">vk::raii::Context</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// instantiate a vk::raii::Instance, given a vk::raii::Context context and a vk::InstanceCreateInfo instanceCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Instance.html">vk::raii::Instance</a> instance( context, instanceCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Instance_html"><div class="ttname"><a href="classvk_1_1raii_1_1Instance.html">vk::raii::Instance</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:2773</div></div>
</div><!-- fragment --><p>The <code><a class="el" href="classvk_1_1raii_1_1Instance.html">vk::raii::Instance</a></code> now holds all the instance-related functions. For example, to get all the <code><a class="el" href="structvk_1_1PhysicalDeviceGroupProperties.html">vk::PhysicalDeviceGroupProperties</a></code> for an instance, your call would look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// get all vk::PhysicalDeviceGroupProperties from a vk::raii::Instance instance</span></div>
<div class="line">std::vector&lt;vk::PhysicalDeviceGroupProperties&gt; physicalDeviceGroupProperties = instance.enumeratePhysicalDeviceGroups();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md74"></a>
02 Enumerate the vk::raii::PhysicalDevices</h2>
<p>Enumerating the physical devices of an instance is slightly different in <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> namespace as you might be used to from the vk-namespace or the pure C-API. As there might be multiple physical devices attached, you would instantiate a <code><a class="el" href="classvk_1_1raii_1_1PhysicalDevices.html">vk::raii::PhysicalDevices</a></code> (note the trailing 's' here!), which essentially is a <code>std::vector</code> of <code><a class="el" href="classvk_1_1raii_1_1PhysicalDevice.html">vk::raii::PhysicalDevice</a></code>s (note the trailing 's' here!):</p>
<div class="fragment"><div class="line"><span class="comment">// enumerate the vk::raii::PhysicalDevices, given a vk::raii::Instance instance</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1PhysicalDevices.html">vk::raii::PhysicalDevices</a> physicalDevices( instance );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1PhysicalDevices_html"><div class="ttname"><a href="classvk_1_1raii_1_1PhysicalDevices.html">vk::raii::PhysicalDevices</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:3486</div></div>
</div><!-- fragment --><p>As <a class="el" href="classvk_1_1raii_1_1PhysicalDevices.html">vk::raii::PhysicalDevices</a> is just a <code>std::vector&lt;<a class="el" href="classvk_1_1raii_1_1PhysicalDevice.html">vk::raii::PhysicalDevice</a>&gt;</code>, you can access any specific <code><a class="el" href="namespacevk_1_1raii.html">vk::raii</a>:PhysicalDevice</code> by indexing into that <code>std::vector</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// get the vk::LayerProperties of the vk::raii::PhysicalDevice with index physicalDeviceIndex, given a vk::raii::PhysicalDevices physicalDevices</span></div>
<div class="line">std::vector&lt;vk::LayerProperties&gt; layerProperties = physicalDevices[physicalDeviceIndex].enumerateDeviceLayerProperties();</div>
</div><!-- fragment --><p>You can as well get one <code><a class="el" href="classvk_1_1raii_1_1PhysicalDevice.html">vk::raii::PhysicalDevice</a></code> out of a <code><a class="el" href="classvk_1_1raii_1_1PhysicalDevices.html">vk::raii::PhysicalDevices</a></code> like this:</p>
<div class="fragment"><div class="line"><span class="comment">// get the vk::raii::PhysicalDevice with index physicalDeviceIndex, given a vk::raii::PhysicalDevices physicalDevices object:</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1PhysicalDevice.html">vk::raii::PhysicalDevice</a> physicalDevice( std::move( physicalDevices[physicalDeviceIndex] ) );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1PhysicalDevice_html"><div class="ttname"><a href="classvk_1_1raii_1_1PhysicalDevice.html">vk::raii::PhysicalDevice</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:3054</div></div>
</div><!-- fragment --><p>Note, that even though the actual <code>VkPhysicalDevice</code> owned by a <code><a class="el" href="classvk_1_1raii_1_1PhysicalDevice.html">vk::raii::PhysicalDevice</a></code> is not a destructible resource, for consistency reasons a <code><a class="el" href="classvk_1_1raii_1_1PhysicalDevice.html">vk::raii::PhysicalDevice</a></code> is a movable but not copyable object just like all the other <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> objects.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
03 Create a vk::raii::Device</h2>
<p>To create a <code><a class="el" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a></code>, you just instantiate an object of that class:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Device, given a vk::raii::PhysicalDevice physicalDevice and a vk::DeviceCreateInfo deviceCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a> device( physicalDevice, deviceCreateInfo );</div>
</div><!-- fragment --><p>For each instantiated <code><a class="el" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a></code>, the device-specific Vulkan function pointers are resolved. That is, for multi-device programs, you automatically use the correct device-specific function pointers, and organizing a multi-device program is simplified:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Device per vk::raii::PhysicalDevice, given a vk::raii::PhysicalDevices physicalDevices, and a corresponding array of vk::DeviceCreateInfo deviceCreateInfos</span></div>
<div class="line">std::vector&lt;vk::raii::Device&gt; devices;</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> i = 0; i &lt; physicalDevices.size(); i++ )</div>
<div class="line">{</div>
<div class="line">  devices.push_back( <a class="code" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a>( physicalDevices[i], deviceCreateInfos[i] ) );</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md76"></a>
04 Create a vk::raii::CommandPool and vk::raii::CommandBuffers</h2>
<p>Creating a <code><a class="el" href="classvk_1_1raii_1_1CommandPool.html">vk::raii::CommandPool</a></code> is simply done by instantiating such an object:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::CommandPool, given a vk::raii::Device device and a vk::CommandPoolCreateInfo commandPoolCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1CommandPool.html">vk::raii::CommandPool</a> commandPool( device, commandPoolCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1CommandPool_html"><div class="ttname"><a href="classvk_1_1raii_1_1CommandPool.html">vk::raii::CommandPool</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:5202</div></div>
</div><!-- fragment --><p>As the number of <code><a class="el" href="classvk_1_1raii_1_1CommandBuffer.html">vk::raii::CommandBuffer</a></code>s to allocate from a <code><a class="el" href="classvk_1_1raii_1_1CommandPool.html">vk::raii::CommandPool</a></code> is given by the member <code>commandBufferCount</code> of a <code><a class="el" href="structvk_1_1CommandBufferAllocateInfo.html">vk::CommandBufferAllocateInfo</a></code> structure, it can't be instantiated as a single object. Instead you get a <code><a class="el" href="classvk_1_1raii_1_1CommandBuffers.html">vk::raii::CommandBuffers</a></code> (note the trailing 's' here!), which essentially is a <code>std::vector</code> of <code><a class="el" href="classvk_1_1raii_1_1CommandBuffer.html">vk::raii::CommandBuffer</a></code>s (note the trailing 's' here!).</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::CommandBuffers, given a vk::raii::Device device and a vk::CommandBufferAllocateInfo commandBufferAllocateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1CommandBuffers.html">vk::raii::CommandBuffers</a> commandBuffers( device, commandBufferAllocateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1CommandBuffers_html"><div class="ttname"><a href="classvk_1_1raii_1_1CommandBuffers.html">vk::raii::CommandBuffers</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:6367</div></div>
</div><!-- fragment --><p>Note, that the <code><a class="el" href="structvk_1_1CommandBufferAllocateInfo.html">vk::CommandBufferAllocateInfo</a></code> holds a <code><a class="el" href="classvk_1_1CommandPool.html">vk::CommandPool</a></code> member <code>commandPool</code>. To assign that from a <code><a class="el" href="classvk_1_1raii_1_1CommandPool.html">vk::raii::CommandPool</a></code> you can use the <code>operator*()</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// assign vk::CommandBufferAllocateInfo::commandPool, given a vk::raii::CommandPool commandPool</span></div>
<div class="line">commandBufferAllocateInfo.commandPool = *commandPool;</div>
</div><!-- fragment --><p>As a <code><a class="el" href="classvk_1_1raii_1_1CommandBuffers.html">vk::raii::CommandBuffers</a></code> is just a <code>std::vector&lt;<a class="el" href="classvk_1_1raii_1_1CommandBuffer.html">vk::raii::CommandBuffer</a>&gt;</code>, you can access any specific <code><a class="el" href="namespacevk_1_1raii.html">vk::raii</a>:CommandBuffer</code> by indexing into that <code>std::vector</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// start recording of the vk::raii::CommandBuffer with index commandBufferIndex, given a vk::raii::CommandBuffers commandBuffers</span></div>
<div class="line">commandBuffers[commandBufferIndex].begin();</div>
</div><!-- fragment --><p>You can as well get one <code><a class="el" href="classvk_1_1raii_1_1CommandBuffer.html">vk::raii::CommandBuffer</a></code> out of a <code><a class="el" href="classvk_1_1raii_1_1CommandBuffers.html">vk::raii::CommandBuffers</a></code> like this:</p>
<div class="fragment"><div class="line"><span class="comment">// get the vk::raii::CommandBuffer with index commandBufferIndex, given a vk::raii::CommandBuffers commandBuffers</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1CommandBuffer.html">vk::raii::CommandBuffer</a> commandBuffer( std::move( commandBuffers[commandBufferIndex] ) );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// start recording</span></div>
<div class="line">commandBuffer.begin();</div>
<div class="ttc" id="aclassvk_1_1raii_1_1CommandBuffer_html"><div class="ttname"><a href="classvk_1_1raii_1_1CommandBuffer.html">vk::raii::CommandBuffer</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:5333</div></div>
</div><!-- fragment --><p>There is one important thing to note, regarding command pool and command buffer handling. When you destroy a <code>VkCommandPool</code>, all <code>VkCommandBuffer</code>s allocated from that pool are implicitly freed. That automatism does not work well with the raii-approach. As the <code><a class="el" href="classvk_1_1raii_1_1CommandBuffers.html">vk::raii::CommandBuffers</a></code> are independent objects, they are not automatically destroyed when the <code><a class="el" href="classvk_1_1raii_1_1CommandPool.html">vk::raii::CommandPool</a></code> they are created from is destroyed. Instead, their destructor would try to use an invalid <code><a class="el" href="classvk_1_1raii_1_1CommandPool.html">vk::raii::CommandPool</a></code>, which obviously is an error.</p>
<p>To handle that correctly, you have to make sure, that all <code><a class="el" href="classvk_1_1raii_1_1CommandBuffers.html">vk::raii::CommandBuffers</a></code> generated from a <code><a class="el" href="classvk_1_1raii_1_1CommandPool.html">vk::raii::CommandPool</a></code> are explicitly destroyed before that <code><a class="el" href="classvk_1_1raii_1_1CommandPool.html">vk::raii::CommandPool</a></code> is destroyed!</p>
<h2><a class="anchor" id="autotoc_md77"></a>
05 Create a vk::raii::SwapchainKHR</h2>
<p>To initialize a swap chain, you first instantiate a <code><a class="el" href="classvk_1_1raii_1_1SwapchainKHR.html">vk::raii::SwapchainKHR</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::SwapchainKHR, given a vk::raii::Device device and a vk::SwapchainCreateInfoKHR swapChainCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1SwapchainKHR.html">vk::raii::SwapchainKHR</a> swapchain( device, swapChainCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1SwapchainKHR_html"><div class="ttname"><a href="classvk_1_1raii_1_1SwapchainKHR.html">vk::raii::SwapchainKHR</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:11306</div></div>
</div><!-- fragment --><p>You can get an array of presentable images associated with that swap chain:</p>
<div class="fragment"><div class="line"><span class="comment">// get presentable images associated with vk::raii::SwapchainKHR swapchain</span></div>
<div class="line">std::vector&lt;VkImage&gt; images = swapchain.getImages();</div>
</div><!-- fragment --><p>Note, that you don't get <code><a class="el" href="classvk_1_1raii_1_1Image.html">vk::raii::Image</a></code>s here, but plain <code>VkImage</code>s. They are controlled by the swap chain, and you should not destroy them.</p>
<p>But you can create <code><a class="el" href="classvk_1_1raii_1_1ImageView.html">vk::raii::ImageView</a></code>s out of them:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::ImageView per VkImage, given a vk::raii::Device sevice, a vector of VkImages images and a vk::ImageViewCreateInfo imageViewCreateInfo</span></div>
<div class="line">std::vector&lt;vk::raii::ImageView&gt; imageViews;</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span> image : images )</div>
<div class="line">{</div>
<div class="line">  imageViewCreatInfo.image = image;</div>
<div class="line">  imageViews.push_back( <a class="code" href="classvk_1_1raii_1_1ImageView.html">vk::raii::ImageView</a>( device, imageViewCreateInfo ) );</div>
<div class="line">}</div>
<div class="ttc" id="aclassvk_1_1raii_1_1ImageView_html"><div class="ttname"><a href="classvk_1_1raii_1_1ImageView.html">vk::raii::ImageView</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:8719</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md78"></a>
06 Create a Depth Buffer</h2>
<p>For a depth buffer, you need an image and some device memory and bind the memory to that image. That is, you first create a <a class="el" href="classvk_1_1raii_1_1Image.html">vk::raii::Image</a></p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Image image, given a vk::raii::Device device and a vk::ImageCreateInfo imageCreateInfo</span></div>
<div class="line"><span class="comment">// imageCreateInfo.usage should hold vk::ImageUsageFlagBits::eDepthStencilAttachment</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Image.html">vk::raii::Image</a> depthImage( device, imageCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Image_html"><div class="ttname"><a href="classvk_1_1raii_1_1Image.html">vk::raii::Image</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:8567</div></div>
</div><!-- fragment --><p>To create the corresponding <a class="el" href="classvk_1_1raii_1_1DeviceMemory.html">vk::raii::DeviceMemory</a>, you should determine appropriate values for the <a class="el" href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a>. That is, get the memory requirements from the pDepthImage, and determine some memoryTypeIndex from the pPhysicalDevice's memory properties, requiring <a class="el" href="namespacevk.html#a992ae6ee0441a9ed8ee5039a235fa12ca09388e1a4f83b060e8c86cf6623e419c">vk::MemoryPropertyFlagBits::eDeviceLocal</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// get the vk::MemoryRequirements of the pDepthImage</span></div>
<div class="line"><a class="code" href="structvk_1_1MemoryRequirements.html">vk::MemoryRequirements</a> memoryRequirements = depthImage.getMemoryRequirements();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// determine appropriate memory type index, using some helper function determineMemoryTypeIndex</span></div>
<div class="line"><a class="code" href="structvk_1_1PhysicalDeviceMemoryProperties.html">vk::PhysicalDeviceMemoryProperties</a> memoryProperties = physicalDevice.getMemoryProperties();</div>
<div class="line">uint32_t memoryTypeIndex = determineMemoryTypeIndex( memoryProperties, memoryRequirements.<a class="code" href="structvk_1_1MemoryRequirements.html#a1f5337561d7ef8ae61da03c106aaf10e">memoryTypeBits</a>, <a class="code" href="namespacevk.html#a992ae6ee0441a9ed8ee5039a235fa12ca09388e1a4f83b060e8c86cf6623e419c">vk::MemoryPropertyFlagBits::eDeviceLocal</a> );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a vk::raii::DeviceMemory depthDeviceMemory for the depth buffer</span></div>
<div class="line"><a class="code" href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a> memoryAllocateInfo( memoryRequirements.<a class="code" href="structvk_1_1MemoryRequirements.html#a1a36d6882641fbc74545b60ca7b4a2b4">size</a>, memoryTypeIndex );</div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1DeviceMemory.html">vk::raii::DeviceMemory</a> depthDeviceMemory( device, memoryAllocateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1DeviceMemory_html"><div class="ttname"><a href="classvk_1_1raii_1_1DeviceMemory.html">vk::raii::DeviceMemory</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:7761</div></div>
<div class="ttc" id="anamespacevk_html_a992ae6ee0441a9ed8ee5039a235fa12ca09388e1a4f83b060e8c86cf6623e419c"><div class="ttname"><a href="namespacevk.html#a992ae6ee0441a9ed8ee5039a235fa12ca09388e1a4f83b060e8c86cf6623e419c">vk::MemoryPropertyFlagBits::eDeviceLocal</a></div><div class="ttdeci">@ eDeviceLocal</div></div>
<div class="ttc" id="astructvk_1_1MemoryAllocateInfo_html"><div class="ttname"><a href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:50604</div></div>
<div class="ttc" id="astructvk_1_1MemoryRequirements_html"><div class="ttname"><a href="structvk_1_1MemoryRequirements.html">vk::MemoryRequirements</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:52107</div></div>
<div class="ttc" id="astructvk_1_1MemoryRequirements_html_a1a36d6882641fbc74545b60ca7b4a2b4"><div class="ttname"><a href="structvk_1_1MemoryRequirements.html#a1a36d6882641fbc74545b60ca7b4a2b4">vk::MemoryRequirements::size</a></div><div class="ttdeci">vk::DeviceSize size</div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:52174</div></div>
<div class="ttc" id="astructvk_1_1MemoryRequirements_html_a1f5337561d7ef8ae61da03c106aaf10e"><div class="ttname"><a href="structvk_1_1MemoryRequirements.html#a1f5337561d7ef8ae61da03c106aaf10e">vk::MemoryRequirements::memoryTypeBits</a></div><div class="ttdeci">uint32_t memoryTypeBits</div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:52176</div></div>
<div class="ttc" id="astructvk_1_1PhysicalDeviceMemoryProperties_html"><div class="ttname"><a href="structvk_1_1PhysicalDeviceMemoryProperties.html">vk::PhysicalDeviceMemoryProperties</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:72325</div></div>
</div><!-- fragment --><p>Then you can bind the depth memory to the depth image</p>
<div class="fragment"><div class="line"><span class="comment">// bind the pDepthMemory to the pDepthImage</span></div>
<div class="line">depthImage.bindMemory( *depthDeviceMemory, 0 );</div>
</div><!-- fragment --><p>Finally, you can create an image view on that depth buffer image</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::ImageView depthView, given a vk::ImageViewCreateInfo imageViewCreateInfo</span></div>
<div class="line">imageViewCreateInfo.image = *depthImage;</div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1ImageView.html">vk::raii::ImageView</a> depthImageView( device, imageViewCreateInfo );</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md79"></a>
07 Create a Uniform Buffer</h2>
<p>Initializing a uniform buffer is very similar to initializing a depth buffer as described above. You just instantiate a <code><a class="el" href="classvk_1_1raii_1_1Buffer.html">vk::raii::Buffer</a></code> instead of a <code><a class="el" href="classvk_1_1raii_1_1Image.html">vk::raii::Image</a></code>, and a <code><a class="el" href="classvk_1_1raii_1_1DeviceMemory.html">vk::raii::DeviceMemory</a></code>, and bind the memory to the buffer:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Buffer, given a vk::raii::Device device and a vk::BufferCreateInfo bufferCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Buffer.html">vk::raii::Buffer</a> uniformBuffer( device, bufferCreateInfo );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// get memoryRequirements for this uniform buffer</span></div>
<div class="line"><a class="code" href="structvk_1_1MemoryRequirements.html">vk::MemoryRequirements</a> memoryRequirements = uniformBuffer.getMemoryRequirements();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// determine appropriate memory type index, using some helper function, given a vk::raii::PhysicalDevice physicalDevice and some memoryPropertyFlags</span></div>
<div class="line"><a class="code" href="structvk_1_1PhysicalDeviceMemoryProperties.html">vk::PhysicalDeviceMemoryProperties</a> memoryProperties = physicalDevice.getMemoryProperties();</div>
<div class="line">uint32_t memoryTypeIndex = determineMemoryTypeIndex( memoryProperties, memoryRequirements.<a class="code" href="structvk_1_1MemoryRequirements.html#a1f5337561d7ef8ae61da03c106aaf10e">memoryTypeBits</a>, memoryPropertyFlags );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a vk::raii::DeviceMemory uniformDeviceMemory for the uniform buffer</span></div>
<div class="line"><a class="code" href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a> memoryAllocateInfo( memoryRequirements.<a class="code" href="structvk_1_1MemoryRequirements.html#a1a36d6882641fbc74545b60ca7b4a2b4">size</a>, memoryTypeIndex );</div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1DeviceMemory.html">vk::raii::DeviceMemory</a> uniformDeviceMemory( device, memoryAllocateInfo );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// bind the vk::raii::DeviceMemory uniformDeviceMemory to the vk::raii::Buffer uniformBuffer</span></div>
<div class="line">uniformBuffer.bindMemory( *uniformDeviceMemory, 0 );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Buffer_html"><div class="ttname"><a href="classvk_1_1raii_1_1Buffer.html">vk::raii::Buffer</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:4828</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md80"></a>
08 Create a vk::raii::PipelineLayout</h2>
<p>To initialize a Pipeline Layout you just have to instantiate a <code><a class="el" href="classvk_1_1raii_1_1DescriptorSetLayout.html">vk::raii::DescriptorSetLayout</a></code> and a <code><a class="el" href="classvk_1_1raii_1_1PipelineLayout.html">vk::raii::PipelineLayout</a></code> using that <code><a class="el" href="classvk_1_1raii_1_1DescriptorSetLayout.html">vk::raii::DescriptorSetLayout</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::DescriptorSetLayout, given a vk::raii::Device device and a vk::DescriptorSetLayoutCreateInfo descriptorSetLayoutCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1DescriptorSetLayout.html">vk::raii::DescriptorSetLayout</a> descriptorSetLayout( device, descriptorSetLayoutCreateInfo );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a vk::raii::PipelineLayout, given a vk::raii::Device device and a vk::raii::DescriptorSetLayout</span></div>
<div class="line"><a class="code" href="structvk_1_1PipelineLayoutCreateInfo.html">vk::PipelineLayoutCreateInfo</a> pipelineLayoutCreateInfo( {}, *descriptorSetLayout );</div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1PipelineLayout.html">vk::raii::PipelineLayout</a> pipelineLayout( device, pipelineLayoutCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1DescriptorSetLayout_html"><div class="ttname"><a href="classvk_1_1raii_1_1DescriptorSetLayout.html">vk::raii::DescriptorSetLayout</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:7515</div></div>
<div class="ttc" id="aclassvk_1_1raii_1_1PipelineLayout_html"><div class="ttname"><a href="classvk_1_1raii_1_1PipelineLayout.html">vk::raii::PipelineLayout</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:9728</div></div>
<div class="ttc" id="astructvk_1_1PipelineLayoutCreateInfo_html"><div class="ttname"><a href="structvk_1_1PipelineLayoutCreateInfo.html">vk::PipelineLayoutCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:92424</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md81"></a>
09 Create a vk::raii::DescriptorPool and vk::raii::DescriptorSets</h2>
<p>The Descriptor Set handling with <code><a class="el" href="namespacevk_1_1raii.html">vk::raii</a></code> requires some special handling that is not needed when using the pure C-API or the vk-namespace!</p>
<p>As a <code><a class="el" href="classvk_1_1raii_1_1DescriptorSet.html">vk::raii::DescriptorSet</a></code> object destroys itself in the destructor, you have to instantiate the corresponding <code><a class="el" href="classvk_1_1raii_1_1DescriptorPool.html">vk::raii::DescriptorPool</a></code> with the <code><a class="el" href="structvk_1_1DescriptorPoolCreateInfo.html#a115f618428aecfa18b2dfe3292b9a9ef">vk::DescriptorPoolCreateInfo::flags</a></code> set to (at least) <code><a class="el" href="namespacevk.html#aecae18fd7a331e614fea382321ad8e22afc7a77a8de4a9fed2db4dd61d92dc5b1">vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet</a></code>. Otherwise, such individual destruction of a <code><a class="el" href="classvk_1_1raii_1_1DescriptorSet.html">vk::raii::DescriptorSet</a></code> would not be allowed!</p>
<p>That is, an instantiation of a <code><a class="el" href="classvk_1_1raii_1_1DescriptorPool.html">vk::raii::DescriptorPool</a></code> would look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::DescriptorPool, given a vk::raii::Device device and a vk::DescriptorPoolCreateInfo descriptorPoolCreateInfo</span></div>
<div class="line">assert( descriptorPoolCreateInfo.flags &amp; <a class="code" href="namespacevk.html#aecae18fd7a331e614fea382321ad8e22afc7a77a8de4a9fed2db4dd61d92dc5b1">vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet</a> );</div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1DescriptorPool.html">vk::raii::DescriptorPool</a> descriptorPool( device, descriptorPoolCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1DescriptorPool_html"><div class="ttname"><a href="classvk_1_1raii_1_1DescriptorPool.html">vk::raii::DescriptorPool</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:7244</div></div>
<div class="ttc" id="anamespacevk_html_aecae18fd7a331e614fea382321ad8e22afc7a77a8de4a9fed2db4dd61d92dc5b1"><div class="ttname"><a href="namespacevk.html#aecae18fd7a331e614fea382321ad8e22afc7a77a8de4a9fed2db4dd61d92dc5b1">vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet</a></div><div class="ttdeci">@ eFreeDescriptorSet</div></div>
</div><!-- fragment --><p>To actually instantiate a <code><a class="el" href="classvk_1_1raii_1_1DescriptorSet.html">vk::raii::DescriptorSet</a></code>, you need a <code><a class="el" href="classvk_1_1raii_1_1DescriptorPool.html">vk::raii::DescriptorPool</a></code>, as just described, and a <code><a class="el" href="classvk_1_1raii_1_1DescriptorSetLayout.html">vk::raii::DescriptorSetLayout</a></code>, similar to the one described in the previous section.</p>
<p>Moreover, as the number of <code><a class="el" href="classvk_1_1raii_1_1DescriptorSet.html">vk::raii::DescriptorSet</a></code>s to allocate from a <code><a class="el" href="classvk_1_1raii_1_1DescriptorPool.html">vk::raii::DescriptorPool</a></code> is given by the number of <code>vk::DescriptorSetLayouts</code> held by a <code><a class="el" href="structvk_1_1DescriptorSetAllocateInfo.html">vk::DescriptorSetAllocateInfo</a></code>, it can't be instantiated as a single object. Instead you get a <code><a class="el" href="classvk_1_1raii_1_1DescriptorSets.html">vk::raii::DescriptorSets</a></code> (note the trailing 's' here!), which essentially is a <code>std::vector</code> of <code><a class="el" href="classvk_1_1raii_1_1DescriptorSet.html">vk::raii::DescriptorSet</a></code>s (note the trailing 's' here!).</p>
<p>When you want to create just one <code><a class="el" href="classvk_1_1raii_1_1DescriptorSet.html">vk::raii::DescriptorSet</a></code>, using just one <code><a class="el" href="classvk_1_1raii_1_1DescriptorSetLayout.html">vk::raii::DescriptorSetLayout</a></code>, your code might look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::DescriptorSets, holding a single vk::raii::DescriptorSet, given a vk::raii::Device device, a vk::raii::DescriptorPool descriptorPool, and a single vk::raii::DescriptorSetLayout descriptorSetLayout</span></div>
<div class="line"><a class="code" href="structvk_1_1DescriptorSetAllocateInfo.html">vk::DescriptorSetAllocateInfo</a> descriptorSetAllocateInfo( *descriptorPool, *descriptorSetLayout );</div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1DescriptorSets.html">vk::raii::DescriptorSets</a> pDescriptorSets( device, descriptorSetAllocateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1DescriptorSets_html"><div class="ttname"><a href="classvk_1_1raii_1_1DescriptorSets.html">vk::raii::DescriptorSets</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:7489</div></div>
<div class="ttc" id="astructvk_1_1DescriptorSetAllocateInfo_html"><div class="ttname"><a href="structvk_1_1DescriptorSetAllocateInfo.html">vk::DescriptorSetAllocateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:24580</div></div>
</div><!-- fragment --><p>And, again similar to the <a class="el" href="classvk_1_1raii_1_1CommandBuffers.html">vk::raii::CommandBuffers</a> handling described above, you can get one <code><a class="el" href="classvk_1_1raii_1_1DescriptorSet.html">vk::raii::DescriptorSet</a></code> out of a <code><a class="el" href="classvk_1_1raii_1_1DescriptorSets.html">vk::raii::DescriptorSets</a></code> like this:</p>
<div class="fragment"><div class="line"><span class="comment">// get the vk::raii::DescriptorSet with index descriptorSetIndex, given a vk::raii::DescriptorSets descriptorSets</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1DescriptorSet.html">vk::raii::DescriptorSet</a> descriptorSet( std::move( descriptorSets[descriptorSetIndex] ) );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1DescriptorSet_html"><div class="ttname"><a href="classvk_1_1raii_1_1DescriptorSet.html">vk::raii::DescriptorSet</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:7368</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md82"></a>
10 Create a vk::raii::RenderPass</h2>
<p>Creating a <code><a class="el" href="classvk_1_1raii_1_1RenderPass.html">vk::raii::RenderPass</a></code> is pretty simple, given you already have a meaningful <code><a class="el" href="structvk_1_1RenderPassCreateInfo.html">vk::RenderPassCreateInfo</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::RenderPass, given a vk::raii::Device device and a vk::RenderPassCreateInfo renderPassCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1RenderPass.html">vk::raii::RenderPass</a> renderPass( device, renderPassCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1RenderPass_html"><div class="ttname"><a href="classvk_1_1raii_1_1RenderPass.html">vk::raii::RenderPass</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:10260</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md83"></a>
11 Create a vk::raii::ShaderModule</h2>
<p>Again, creating a <code><a class="el" href="classvk_1_1raii_1_1ShaderModule.html">vk::raii::ShaderModule</a></code> is simple, given a <code><a class="el" href="structvk_1_1ShaderModuleCreateInfo.html">vk::ShaderModuleCreateInfo</a></code> with some meaningful code:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::ShaderModule, given a vk::raii::Device device and a vk::ShaderModuleCreateInfo shaderModuleCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1ShaderModule.html">vk::raii::ShaderModule</a> shaderModule( device, shaderModuleCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1ShaderModule_html"><div class="ttname"><a href="classvk_1_1raii_1_1ShaderModule.html">vk::raii::ShaderModule</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:10912</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md84"></a>
12 Create vk::raii::Framebuffers</h2>
<p>If you have a <code>std::vector&lt;<a class="el" href="classvk_1_1raii_1_1ImageView.html">vk::raii::ImageView</a>&gt;</code> as described in chapter 05 above, with one view per <code>VkImage</code> that you got from a <code><a class="el" href="classvk_1_1raii_1_1SwapchainKHR.html">vk::raii::SwapchainKHR</a></code>; and one <code><a class="el" href="classvk_1_1raii_1_1ImageView.html">vk::raii::ImageView</a></code> as described in chapter 06 above, which is a view on a <code><a class="el" href="classvk_1_1raii_1_1Image.html">vk::raii::Image</a></code>, that is supposed to be a depth buffer, you can create a <code><a class="el" href="classvk_1_1raii_1_1Framebuffer.html">vk::raii::Framebuffer</a></code> per swapchain image.</p>
<div class="fragment"><div class="line"><span class="comment">// create a vector of vk::raii::Framebuffer, given a vk::raii::ImageView depthImageView, a vector of vk::raii::ImageView swapchainImageViews, a vk::raii::RenderPass renderPass, a vk::raii::Devie device, and some width and height</span></div>
<div class="line"><span class="comment">// use the depth image view as the second attachment for each vk::raii::Framebuffer</span></div>
<div class="line">std::array&lt;vk::ImageView, 2&gt; attachments;</div>
<div class="line">attachments[1] = *depthImageView;</div>
<div class="line">std::vector&lt;vk::raii::Framebuffer&gt; framebuffers;</div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keyword">auto</span> <span class="keyword">const</span> &amp; imageView : swapchainImageViews )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// use each image view from the swapchain as the first attachment</span></div>
<div class="line">  attachments[0] = *imageView;</div>
<div class="line">  <a class="code" href="structvk_1_1FramebufferCreateInfo.html">vk::FramebufferCreateInfo</a> framebufferCreateInfo( {}, *renderPass, attachments, width, height, 1 );</div>
<div class="line">  framebuffers.push_back( <a class="code" href="classvk_1_1raii_1_1Framebuffer.html">vk::raii::Framebuffer</a>( device, framebufferCreateInfo ) );</div>
<div class="line">}</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Framebuffer_html"><div class="ttname"><a href="classvk_1_1raii_1_1Framebuffer.html">vk::raii::Framebuffer</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:8444</div></div>
<div class="ttc" id="astructvk_1_1FramebufferCreateInfo_html"><div class="ttname"><a href="structvk_1_1FramebufferCreateInfo.html">vk::FramebufferCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:38416</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md85"></a>
13 Initialize a Vertex Buffer</h2>
<p>To initialize a vertex buffer, you essentially have to combine some of the pieces described in the chapters before. First, you need to create a <code><a class="el" href="classvk_1_1raii_1_1Buffer.html">vk::raii::Buffer</a></code> and a <code><a class="el" href="classvk_1_1raii_1_1DeviceMemory.html">vk::raii::DeviceMemory</a></code> and bind them:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Buffer vertexBuffer, given a vk::raii::Device device and some vertexData in host memory</span></div>
<div class="line"><a class="code" href="structvk_1_1BufferCreateInfo.html">vk::BufferCreateInfo</a> bufferCreateInfo( {}, <span class="keyword">sizeof</span>( vertexData ), <a class="code" href="namespacevk.html#a161c840775e505e3e966e912218b8631a14d069b9695b30ef0a41e6ddda094129">vk::BufferUsageFlagBits::eVertexBuffer</a> );</div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Buffer.html">vk::raii::Buffer</a> vertexBuffer( device, bufferCreateInfo );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a vk::raii::DeviceMemory vertexDeviceMemory, given a vk::raii::Device device and a uint32_t memoryTypeIndex</span></div>
<div class="line"><a class="code" href="structvk_1_1MemoryRequirements.html">vk::MemoryRequirements</a> memoryRequirements = vertexBuffer.getMemoryRequirements();</div>
<div class="line"><a class="code" href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a> memoryAllocateInfo( memoryRequirements.<a class="code" href="structvk_1_1MemoryRequirements.html#a1a36d6882641fbc74545b60ca7b4a2b4">size</a>, memoryTypeIndex );</div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1DeviceMemory.html">vk::raii::DeviceMemory</a> vertexDeviceMemory( device, memoryAllocateInfo );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// bind the complete device memory to the vertex buffer</span></div>
<div class="line">vertexBuffer.bindMemory( *vertexDeviceMemory, 0 );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// copy the vertex data into the vertexDeviceMemory</span></div>
<div class="line">...</div>
<div class="ttc" id="anamespacevk_html_a161c840775e505e3e966e912218b8631a14d069b9695b30ef0a41e6ddda094129"><div class="ttname"><a href="namespacevk.html#a161c840775e505e3e966e912218b8631a14d069b9695b30ef0a41e6ddda094129">vk::BufferUsageFlagBits::eVertexBuffer</a></div><div class="ttdeci">@ eVertexBuffer</div></div>
<div class="ttc" id="astructvk_1_1BufferCreateInfo_html"><div class="ttname"><a href="structvk_1_1BufferCreateInfo.html">vk::BufferCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:11618</div></div>
</div><!-- fragment --><p>Later on, you can bind that vertex buffer to a command buffer:</p>
<div class="fragment"><div class="line"><span class="comment">// bind a complete single vk::raii::Buffer vertexBuffer as a vertex buffer, given a vk::raii::CommandBuffer commandBuffer</span></div>
<div class="line">commandBuffer.bindVertexBuffer( 0, { *vertexBuffer }, { 0 } );</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md86"></a>
14 Initialize a Graphics Pipeline</h2>
<p>Initializing a graphics pipeline is not very raii-specific. Just instantiate it, provided you have a valid <a class="el" href="structvk_1_1GraphicsPipelineCreateInfo.html">vk::GraphicsPipelineCreateInfo</a>:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Pipeline, given a vk::raii::Device device and a vk::GraphicsPipelineCreateInfo graphicsPipelineCreateInfo</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Pipeline.html">vk::raii::Pipeline</a> graphicsPipeline( device, graphicsPipelineCreateInfo );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Pipeline_html"><div class="ttname"><a href="classvk_1_1raii_1_1Pipeline.html">vk::raii::Pipeline</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:9440</div></div>
</div><!-- fragment --><p>The only thing to keep in mind here is the dereferencing of raii handles, like <code>pipelineLayout</code> or <code>renderPass</code> in the <code><a class="el" href="structvk_1_1GraphicsPipelineCreateInfo.html">vk::GraphicsPipelineCreateInfo</a></code>:</p>
<div class="fragment"><div class="line"><a class="code" href="structvk_1_1GraphicsPipelineCreateInfo.html">vk::GraphicsPipelineCreateInfo</a> graphicsPipelineCreateInfo(</div>
<div class="line">  {},                                    <span class="comment">// flags</span></div>
<div class="line">  pipelineShaderStageCreateInfos,        <span class="comment">// stages</span></div>
<div class="line">  &amp;pipelineVertexInputStateCreateInfo,   <span class="comment">// pVertexInputState</span></div>
<div class="line">  &amp;pipelineInputAssemblyStateCreateInfo, <span class="comment">// pInputAssemblyState</span></div>
<div class="line">  <span class="keyword">nullptr</span>,                               <span class="comment">// pTessellationState</span></div>
<div class="line">  &amp;pipelineViewportStateCreateInfo,      <span class="comment">// pViewportState</span></div>
<div class="line">  &amp;pipelineRasterizationStateCreateInfo, <span class="comment">// pRasterizationState</span></div>
<div class="line">  &amp;pipelineMultisampleStateCreateInfo,   <span class="comment">// pMultisampleState</span></div>
<div class="line">  &amp;pipelineDepthStencilStateCreateInfo,  <span class="comment">// pDepthStencilState</span></div>
<div class="line">  &amp;pipelineColorBlendStateCreateInfo,    <span class="comment">// pColorBlendState</span></div>
<div class="line">  &amp;pipelineDynamicStateCreateInfo,       <span class="comment">// pDynamicState</span></div>
<div class="line">  *pipelineLayout,                       <span class="comment">// layout</span></div>
<div class="line">  *renderPass                            <span class="comment">// renderPass</span></div>
<div class="line">);</div>
<div class="ttc" id="astructvk_1_1GraphicsPipelineCreateInfo_html"><div class="ttname"><a href="structvk_1_1GraphicsPipelineCreateInfo.html">vk::GraphicsPipelineCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:41573</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md87"></a>
15 Drawing a Cube</h2>
<p>Finally, we get all those pieces together and draw a cube.</p>
<p>To do so, you need a <code><a class="el" href="classvk_1_1raii_1_1Semaphore.html">vk::raii::Semaphore</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Semaphore, given a vk::raii::Device</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Semaphore.html">vk::raii::Semaphore</a> imageAcquiredSemphore( device, <a class="code" href="structvk_1_1SemaphoreCreateInfo.html">vk::SemaphoreCreateInfo</a>() );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Semaphore_html"><div class="ttname"><a href="classvk_1_1raii_1_1Semaphore.html">vk::raii::Semaphore</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:10635</div></div>
<div class="ttc" id="astructvk_1_1SemaphoreCreateInfo_html"><div class="ttname"><a href="structvk_1_1SemaphoreCreateInfo.html">vk::SemaphoreCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:105762</div></div>
</div><!-- fragment --><p>That semaphore can be used, to acquire the next imageIndex from the <code><a class="el" href="classvk_1_1raii_1_1SwapchainKHR.html">vk::raii::SwapchainKHR</a></code> swapchain:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">vk::Result</a> result;</div>
<div class="line">uint32_t imageIndex;</div>
<div class="line">std::tie( result, imageIndex ) = swapchain.acquireNextImage( timeout, *imageAcquiredSemaphore );</div>
<div class="ttc" id="anamespacevk_html_abda4f7ea9e913d7eb358776d793488df"><div class="ttname"><a href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">vk::Result</a></div><div class="ttdeci">Result</div><div class="ttdef"><b>Definition:</b> vulkan_enums.hpp:231</div></div>
</div><!-- fragment --><p>Note, <code><a class="el" href="classvk_1_1raii_1_1SwapchainKHR.html#a804abb0f2fcb3cfe52fe26c841594f9d">vk::raii::SwapchainKHR::acquireNextImage</a></code> returns a <code>std::pair&lt;<a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">vk::Result</a>, uint32_t&gt;</code>, that can nicely be assigned onto two separate values using std::tie().</p>
<p>And also note, the returned <code><a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">vk::Result</a></code> can not only be <code><a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa27a410c6b361732f3b4237bff6478a44">vk::Result::eSuccess</a></code>, but also <code><a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa1be2d08eb04888bcbe7642b5d9d892eb">vk::Result::eTimeout</a></code>, <code><a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa263738e8a79018589c9e21d776e711ff">vk::Result::eNotReady</a></code>, or <code><a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfaf7de6c5e9a7662df46b60828a3980c73">vk::Result::eSuboptimalKHR</a></code>, which should be handled here accordingly!</p>
<p>Next, you can record some commands into a <code><a class="el" href="classvk_1_1raii_1_1CommandBuffer.html">vk::raii::CommandBuffer</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// open the commandBuffer for recording</span></div>
<div class="line">commandBuffer.begin( {} );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initialize a vk::RenderPassBeginInfo with the current imageIndex and some appropriate renderArea and clearValues</span></div>
<div class="line"><a class="code" href="structvk_1_1RenderPassBeginInfo.html">vk::RenderPassBeginInfo</a> renderPassBeginInfo( *renderPass, *framebuffers[imageIndex], renderArea, clearValues );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// begin the render pass with an inlined subpass; no secondary command buffers allowed</span></div>
<div class="line">commandBuffer.beginRenderPass( renderPassBeginInfo, <a class="code" href="namespacevk.html#ab90e800a31aceef36d2e24c18a644e38a91eb612cf03675bc6b0783f122524167">vk::SubpassContents::eInline</a> );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// bind the graphics pipeline</span></div>
<div class="line">commandBuffer.bindPipeline( <a class="code" href="namespacevk.html#a34523678703507c282981ebfa94fdeacaae96dc49a56fd0c22927d672cb979537">vk::PipelineBindPoint::eGraphics</a>, *graphicsPipeline );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// bind an appropriate descriptor set</span></div>
<div class="line">commandBuffer.bindDescriptorSets( <a class="code" href="namespacevk.html#a34523678703507c282981ebfa94fdeacaae96dc49a56fd0c22927d672cb979537">vk::PipelineBindPoint::eGraphics</a>, *pipelineLayout, 0, { *descriptorSet }, nullptr );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// bind the vertex buffer</span></div>
<div class="line">commandBuffer.bindVertexBuffers( 0, { *vertexBuffer }, { 0 } );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set viewport and scissor</span></div>
<div class="line">commandBuffer.setViewport( 0, viewport );</div>
<div class="line">commandBuffer.setScissor( renderArea );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// draw the 12 * 3 vertices once, starting with vertex 0 and instance 0</span></div>
<div class="line">commandBuffer.draw( 12 * 3, 1, 0, 0 );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// end the render pass and stop recording</span></div>
<div class="line">commandBuffer.endRenderPass();</div>
<div class="line">commandBuffer.end();</div>
<div class="ttc" id="anamespacevk_html_a34523678703507c282981ebfa94fdeacaae96dc49a56fd0c22927d672cb979537"><div class="ttname"><a href="namespacevk.html#a34523678703507c282981ebfa94fdeacaae96dc49a56fd0c22927d672cb979537">vk::PipelineBindPoint::eGraphics</a></div><div class="ttdeci">@ eGraphics</div></div>
<div class="ttc" id="anamespacevk_html_ab90e800a31aceef36d2e24c18a644e38a91eb612cf03675bc6b0783f122524167"><div class="ttname"><a href="namespacevk.html#ab90e800a31aceef36d2e24c18a644e38a91eb612cf03675bc6b0783f122524167">vk::SubpassContents::eInline</a></div><div class="ttdeci">@ eInline</div></div>
<div class="ttc" id="astructvk_1_1RenderPassBeginInfo_html"><div class="ttname"><a href="structvk_1_1RenderPassBeginInfo.html">vk::RenderPassBeginInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:99946</div></div>
</div><!-- fragment --><p>To submit that command buffer to a <code><a class="el" href="classvk_1_1raii_1_1Queue.html">vk::raii::Queue</a></code> graphicsQueue you might want to use a <code><a class="el" href="classvk_1_1raii_1_1Fence.html">vk::raii::Fence</a></code></p>
<div class="fragment"><div class="line"><span class="comment">// create a vk::raii::Fence, given a vk::raii::Device device</span></div>
<div class="line"><a class="code" href="classvk_1_1raii_1_1Fence.html">vk::raii::Fence</a> fence( device, <a class="code" href="structvk_1_1FenceCreateInfo.html">vk::FenceCreateInfo</a>() );</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Fence_html"><div class="ttname"><a href="classvk_1_1raii_1_1Fence.html">vk::raii::Fence</a></div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:8302</div></div>
<div class="ttc" id="astructvk_1_1FenceCreateInfo_html"><div class="ttname"><a href="structvk_1_1FenceCreateInfo.html">vk::FenceCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:37100</div></div>
</div><!-- fragment --><p>With that, you can fill a <code><a class="el" href="structvk_1_1SubmitInfo.html">vk::SubmitInfo</a></code> and submit the command buffer</p>
<div class="fragment"><div class="line"><a class="code" href="classvk_1_1Flags.html">vk::PipelineStageFlags</a> waitDestinationStageMask( <a class="code" href="namespacevk.html#a9bd377d70b639c2772f255b812f5db85a799a575d1660453fff4cae31f16942f7">vk::PipelineStageFlagBits::eColorAttachmentOutput</a> );</div>
<div class="line"><a class="code" href="structvk_1_1SubmitInfo.html">vk::SubmitInfo</a> submitInfo( *imageAcquiredSemaphore, waitDestinationStageMask, *commandBuffer );</div>
<div class="line">graphicsQueue.submit( submitInfo, *fence );</div>
<div class="ttc" id="aclassvk_1_1Flags_html"><div class="ttname"><a href="classvk_1_1Flags.html">vk::Flags&lt; PipelineStageFlagBits &gt;</a></div></div>
<div class="ttc" id="anamespacevk_html_a9bd377d70b639c2772f255b812f5db85a799a575d1660453fff4cae31f16942f7"><div class="ttname"><a href="namespacevk.html#a9bd377d70b639c2772f255b812f5db85a799a575d1660453fff4cae31f16942f7">vk::PipelineStageFlagBits::eColorAttachmentOutput</a></div><div class="ttdeci">@ eColorAttachmentOutput</div></div>
<div class="ttc" id="astructvk_1_1SubmitInfo_html"><div class="ttname"><a href="structvk_1_1SubmitInfo.html">vk::SubmitInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:108407</div></div>
</div><!-- fragment --><p>At some later point, you can wait for that submit being ready by waiting for the fence</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> ( <a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa1be2d08eb04888bcbe7642b5d9d892eb">vk::Result::eTimeout</a> == device.<a class="code" href="classvk_1_1raii_1_1Device.html#a1264d5b5e72164611fe9eb7c0374fd22">waitForFences</a>( { *fence }, <a class="code" href="vulkan__core_8h.html#a194519942d53e7f5fe402ae75f6ec1b4">VK_TRUE</a>, timeout ) )</div>
<div class="line">  ;</div>
<div class="ttc" id="aclassvk_1_1raii_1_1Device_html_a1264d5b5e72164611fe9eb7c0374fd22"><div class="ttname"><a href="classvk_1_1raii_1_1Device.html#a1264d5b5e72164611fe9eb7c0374fd22">vk::raii::Device::waitForFences</a></div><div class="ttdeci">VULKAN_HPP_NODISCARD vk::Result waitForFences(vk::ArrayProxy&lt; const vk::Fence &gt; const &amp;fences, vk::Bool32 waitAll, uint64_t timeout) const</div><div class="ttdef"><b>Definition:</b> vulkan_raii.hpp:12460</div></div>
<div class="ttc" id="anamespacevk_html_abda4f7ea9e913d7eb358776d793488dfa1be2d08eb04888bcbe7642b5d9d892eb"><div class="ttname"><a href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa1be2d08eb04888bcbe7642b5d9d892eb">vk::Result::eTimeout</a></div><div class="ttdeci">@ eTimeout</div></div>
<div class="ttc" id="avulkan__core_8h_html_a194519942d53e7f5fe402ae75f6ec1b4"><div class="ttname"><a href="vulkan__core_8h.html#a194519942d53e7f5fe402ae75f6ec1b4">VK_TRUE</a></div><div class="ttdeci">#define VK_TRUE</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:131</div></div>
</div><!-- fragment --><p>And finally, you can use the <code><a class="el" href="classvk_1_1raii_1_1Queue.html">vk::raii::Queue</a></code> presentQueue to, well, present that image</p>
<div class="fragment"><div class="line"><a class="code" href="structvk_1_1PresentInfoKHR.html">vk::PresentInfoKHR</a> presentInfoKHR( <span class="keyword">nullptr</span>, *swapChain, imageIndex );</div>
<div class="line">result = presentQueue.presentKHR( presentInfoKHR );</div>
<div class="ttc" id="astructvk_1_1PresentInfoKHR_html"><div class="ttname"><a href="structvk_1_1PresentInfoKHR.html">vk::PresentInfoKHR</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:95884</div></div>
</div><!-- fragment --><p>Note here, again, that <code>result</code> can not only be <code><a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa27a410c6b361732f3b4237bff6478a44">vk::Result::eSuccess</a></code>, but also <code><a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfaf7de6c5e9a7662df46b60828a3980c73">vk::Result::eSuboptimalKHR</a></code>, which should be handled accordingly.</p>
<h1><a class="anchor" id="autotoc_md88"></a>
Conclusion</h1>
<p>With the <a class="el" href="namespacevk_1_1raii.html">vk::raii</a> namespace you've got a complete set of Vulkan handle wrapper classes following the RAII-paradigm. That is, they can easily be assigned to a smart pointer. And you can't miss their destruction.</p>
<p>Moreover, the actual function pointer handling is done automatically by <code><a class="el" href="classvk_1_1raii_1_1Context.html">vk::raii::Context</a></code>, <code><a class="el" href="classvk_1_1raii_1_1Instance.html">vk::raii::Instance</a></code>, and <code><a class="el" href="classvk_1_1raii_1_1Device.html">vk::raii::Device</a></code>. That is, you always use the correct device-specific functions, no matter how many devices you're using.</p>
<p>Note, though, that there are a few classes, like <code><a class="el" href="classvk_1_1raii_1_1CommandPool.html">vk::raii::CommandPool</a></code> and <code><a class="el" href="classvk_1_1raii_1_1DescriptorSet.html">vk::raii::DescriptorSet</a></code>, that need some special handling that deviates from what you can do with the pure C-API or the wrapper classes in the vk-namespace. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
