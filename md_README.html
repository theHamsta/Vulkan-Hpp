<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vulkan-Hpp: Vulkan-Hpp: C++ Bindings for Vulkan</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vulkan-Hpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Vulkan-Hpp: C++ Bindings for Vulkan </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The goal of the Vulkan-Hpp is to provide header only C++ bindings for the Vulkan C API to improve the developers Vulkan experience without introducing CPU runtime cost. It adds features like type safety for enums and bitfields, STL container support, exceptions and simple enumerations.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Platform   </th><th class="markdownTableHeadCenter">Build Status    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">Linux   </td><td class="markdownTableBodyCenter"><a href="https://travis-ci.org/KhronosGroup/Vulkan-Hpp"><img src="https://travis-ci.org/KhronosGroup/Vulkan-Hpp.svg?branch=master" alt="Build Status" style="pointer-events: none;" class="inline"/></a>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md1"></a>
Getting Started</h1>
<p>Vulkan-Hpp is part of the LunarG Vulkan SDK since version 1.0.24. Just <code>#include &lt;<a class="el" href="vulkan_8hpp.html">vulkan/vulkan.hpp</a>&gt;</code> and you're ready to use the C++ bindings. If you're using a Vulkan version not yet supported by the Vulkan SDK you can find the latest version of the header <a href="https://github.com/KhronosGroup/Vulkan-Hpp/blob/master/vulkan/vulkan.hpp">here</a>.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Minimum Requirements</h2>
<p>Vulkan-Hpp requires a C++11 capable compiler to compile. The following compilers are known to work:</p><ul>
<li>Visual Studio &gt;=2015</li>
<li>GCC &gt;= 4.8.2 (earlier version might work, but are untested)</li>
<li>Clang &gt;= 3.3</li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
Building Vulkan-Hpp, Samples, and Tests</h2>
<p>To build the local samples and tests you'll have to clone this repository and run CMake to generate the required build files</p>
<p>0. Install dependencies.</p><ul>
<li>Ensure that you have CMake and git installed and accessible from a shell.</li>
<li>Ensure that you have installed the Vulkan SDK.</li>
<li>Optionally install clang-format &gt;= 11.0 to get a nicely formatted Vulkan-Hpp header.</li>
</ul>
<p>Open a shell which provides git and clone the repository with: <code>git clone --recurse-submodules <a href="https://github.com/KhronosGroup/Vulkan-Hpp.git">https://github.com/KhronosGroup/Vulkan-Hpp.git</a></code></p><ol type="1">
<li>Change the current directory to the newly created Vulkan-Hpp directory.</li>
<li>Create a build environment with CMake <code>cmake -DVULKAN_HPP_SAMPLES_BUILD=ON -DVULKAN_HPP_SAMPLES_BUILD_WITH_LOCAL_VULKAN_HPP=ON -DVULKAN_HPP_TESTS_BUILD=ON -DVULKAN_HPP_TESTS_BUILD_WITH_LOCAL_VULKAN_HPP=ON -B build</code> You might have to specify a generator via <code>-G</code>, for a full list of generators execute <code>cmake -G</code>.<ul>
<li>To rebuild <code><a class="el" href="vulkan_8hpp.html">vulkan.hpp</a></code> from the <code>vk.xml</code> XML registry file, add the <code>-DVULKAN_HPP_RUN_GENERATOR=ON</code> option to the CMake command line.</li>
</ul>
</li>
<li>Either open the generated project with an IDE, e.g. Visual Studio or launch the build process with <code>cmake --build build --parallel</code>.</li>
</ol>
<p>Optional: To update the Vulkan-Hpp and its submodules execute <code>git pull --recurse-submodules</code>.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Installing vulkan-hpp using vcpkg</h2>
<p>You can download and install vulkan-hpp using the <a href="https://github.com/Microsoft/vcpkg">vcpkg</a> dependency manager:</p>
<div class="fragment"><div class="line">git clone https://github.com/Microsoft/vcpkg.git</div>
<div class="line">cd vcpkg</div>
<div class="line">./bootstrap-vcpkg.sh</div>
<div class="line">./vcpkg integrate install</div>
<div class="line">./vcpkg install vulkan-headers</div>
</div><!-- fragment --><p>The vulkan-hpp port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please <a href="https://github.com/Microsoft/vcpkg">create an issue or pull request</a> on the vcpkg repository.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Optional Features</h2>
<h3><a class="anchor" id="autotoc_md6"></a>
Formatting</h3>
<p>If the program clang-format is found by CMake, the define CLANG_FORMAT_EXECUTABLE is set accordingly. In that case, the generated <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> is formatted using the .clang-format file located in the root directory of this project. Otherwise it's formatted as hard-coded in the generator.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Custom views of Vulkan-Hpp objects in Visual Studio</h3>
<p>The file VulkanHpp.natvis provides a custom view on <a class="el" href="classvk_1_1Flags.html">vk::Flags</a> for Visual Studio. If you add this file to the user-specific natvis directory of your Visual Studio installation (USERPROFILE%\Documents\Visual Studio 2022\Visualizers), you get <a class="el" href="classvk_1_1Flags.html">vk::Flags</a> nicely formatted in your debugger with all your Visual Studio projects.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Usage</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
namespace vk</h2>
<p>To avoid name collisions with the Vulkan C API the C++ bindings reside in the vk namespace. The following rules apply to the new naming</p>
<ul>
<li>All functions, enums, handles, and structs have the Vk prefix removed. In addition to this the first letter of functions is lower case.<ul>
<li><code>vkCreateInstance</code> can be accessed as <code><a class="el" href="namespacevk.html#ab34f5579e7a4133f2bc5c0c25bba6ab0">vk::createInstance</a></code></li>
<li><code>VkImageTiling</code> can be accessed as <code><a class="el" href="namespacevk.html#a12b12fdc89fcaac07f4fe719939db42e">vk::ImageTiling</a></code></li>
<li><code><a class="el" href="structVkImageCreateInfo.html">VkImageCreateInfo</a></code> can be accessed as <code><a class="el" href="structvk_1_1ImageCreateInfo.html">vk::ImageCreateInfo</a></code></li>
</ul>
</li>
<li>Enums are mapped to scoped enums to provide compile time type safety. The names have been changed to 'e' + CamelCase with the VK_ prefix and type infix removed. In case the enum type is an extension the extension suffix has been removed from the enum values.</li>
</ul>
<p>In all other cases the extension suffix has not been removed.</p><ul>
<li><code>VK_IMAGETYPE_2D</code> is now <code><a class="el" href="namespacevk.html#ab2dd6e797349dbff99ae51686829325cae82a23d307975ac2e52ee0d3cbbef016">vk::ImageType::e2D</a></code>.</li>
<li><code>VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</code> is now <code><a class="el" href="namespacevk.html#a881b9354a9c1c2bc45cc1c8635ffa5beacce14c74e659e95edd37fdbefd47dfb0">vk::ColorSpaceKHR::eSrgbNonlinear</a></code>.</li>
<li><code>VK_STRUCTURE_TYPE_PRESENT_INFO_KHR</code> is now <code><a class="el" href="namespacevk.html#abed5093608f5d9cdc6d680527d6f95b4a90d50f565206eb9f0198a03fe7ec6504">vk::StructureType::ePresentInfoKHR</a></code>.</li>
</ul>
<p>Flag bits are handled like scoped enums with the addition that the <code>_BIT</code> suffix has also been removed.</p>
<p>In some cases it might be necessary to move Vulkan-Hpp to a custom namespace. This can be achieved by defining VULKAN_HPP_NAMESPACE before including Vulkan-Hpp.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Handles</h2>
<p>Vulkan-Hpp declares a class for all handles to ensure full type safety and to add support for member functions on handles. A member function has been added to a handle class for each function which accepts the corresponding handle as first parameter. Instead of <code>vkBindBufferMemory(device, ...)</code> one can write <code>device.bindBufferMemory(...)</code> or <code>vk::bindBufferMemory(device, ...)</code>.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
namespace vk::raii</h2>
<p>There is an additional header named <a class="el" href="vulkan__raii_8hpp.html">vulkan_raii.hpp</a> generated. That header holds raii-compliant wrapper classes for the handle types. That is, for e.g. the handle type VkInstance, there's a raii-compliant wrapper <a class="el" href="classvk_1_1raii_1_1Instance.html">vk::raii::Instance</a>. Please have a look at the samples using those classes in the directory RAII_Samples.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
C/C++ Interop for Handles</h2>
<p>On 64-bit platforms Vulkan-Hpp supports implicit conversions between C++ Vulkan handles and C Vulkan handles. On 32-bit platforms all non-dispatchable handles are defined as <code>uint64_t</code>, thus preventing type-conversion checks at compile time which would catch assignments between incompatible handle types. Due to that Vulkan-Hpp does not enable implicit conversion for 32-bit platforms by default and it is recommended to use a <code>static_cast</code> for the conversion like this: <code>VkImage = static_cast&lt;VkImage&gt;(cppImage)</code> to prevent converting some arbitrary int to a handle or vice versa by accident. If you're developing your code on a 64-bit platform, but want compile your code for a 32-bit platform without adding the explicit casts you can define <code>VULKAN_HPP_TYPESAFE_CONVERSION</code> to 1 in your build system or before including <code><a class="el" href="vulkan_8hpp.html">vulkan.hpp</a></code>. On 64-bit platforms this define is set to 1 by default and can be set to 0 to disable implicit conversions.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Flags</h2>
<p>The scoped enum feature adds type safety to the flags, but also prevents using the flag bits as input for bitwise operations like &amp; and |.</p>
<p>As solution Vulkan-Hpp provides a template class <code><a class="el" href="classvk_1_1Flags.html">vk::Flags</a></code> which brings the standard operations like <code>&amp;=</code>, <code>|=</code>, <code>&amp;</code> and <code>|</code> to our scoped enums. Except for the initialization with 0 this class behaves exactly like a normal bitmask with the improvement that it is impossible to set bits not specified by the corresponding enum by accident. Here are a few examples for the bitmask handling:</p>
<div class="fragment"><div class="line"><a class="code" href="classvk_1_1Flags.html">vk::ImageUsageFlags</a> iu1; <span class="comment">// initialize a bitmask with no bit set</span></div>
<div class="line"><a class="code" href="classvk_1_1Flags.html">vk::ImageUsageFlags</a> iu2 = {}; <span class="comment">// initialize a bitmask with no bit set</span></div>
<div class="line"><a class="code" href="classvk_1_1Flags.html">vk::ImageUsageFlags</a> iu3 = <a class="code" href="namespacevk.html#a68dfed262a1fe58d3fe58875254bd81ea749473a29d801c9b0187fd4931dff4d6">vk::ImageUsageFlagBits::eColorAttachment</a>; <span class="comment">// initialize with a single value</span></div>
<div class="line"><a class="code" href="classvk_1_1Flags.html">vk::ImageUsageFlags</a> iu4 = <a class="code" href="namespacevk.html#a68dfed262a1fe58d3fe58875254bd81ea749473a29d801c9b0187fd4931dff4d6">vk::ImageUsageFlagBits::eColorAttachment</a> | <a class="code" href="namespacevk.html#a68dfed262a1fe58d3fe58875254bd81eae1a7e733531f08074becd467959f0521">vk::ImageUsageFlagBits::eStorage</a>; <span class="comment">// or two bits to get a bitmask</span></div>
<div class="line">PipelineShaderStageCreateInfo ci( {} <span class="comment">/* pass a flag without any bits set */</span>, ...);</div>
<div class="ttc" id="aclassvk_1_1Flags_html"><div class="ttname"><a href="classvk_1_1Flags.html">vk::Flags&lt; ImageUsageFlagBits &gt;</a></div></div>
<div class="ttc" id="anamespacevk_html_a68dfed262a1fe58d3fe58875254bd81ea749473a29d801c9b0187fd4931dff4d6"><div class="ttname"><a href="namespacevk.html#a68dfed262a1fe58d3fe58875254bd81ea749473a29d801c9b0187fd4931dff4d6">vk::ImageUsageFlagBits::eColorAttachment</a></div><div class="ttdeci">@ eColorAttachment</div></div>
<div class="ttc" id="anamespacevk_html_a68dfed262a1fe58d3fe58875254bd81eae1a7e733531f08074becd467959f0521"><div class="ttname"><a href="namespacevk.html#a68dfed262a1fe58d3fe58875254bd81eae1a7e733531f08074becd467959f0521">vk::ImageUsageFlagBits::eStorage</a></div><div class="ttdeci">@ eStorage</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
CreateInfo structs</h2>
<p>When constructing a handle in Vulkan one usually has to create some <code>CreateInfo</code> struct which describes the new handle. This can result in quite lengthy code as can be seen in the following Vulkan C example:</p>
<div class="fragment"><div class="line"><a class="code" href="structVkImageCreateInfo.html">VkImageCreateInfo</a> ci;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#ac55852316bcd80098ac5ba7ba8f1f2e0">sType</a> = <a class="code" href="vulkan__core_8h.html#aff9f2b99398eb80a2b5a146bc5534ce8a6c3f80c9a0267b7a8fa80ebd3344197c">VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</a>;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a2daf972898f6f28c4bbd274f50c6d44a">pNext</a> = <span class="keyword">nullptr</span>;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a01c5855fa62cd93ace4cb43d0fb7271c">flags</a> = ...some flags...;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#aa595c6fabd7b5f39fec5765847bf8525">imageType</a> = <a class="code" href="vulkan__core_8h.html#aa84985704e226942ee3d767563ed17b2a334b34484fb69a5e28522a5837233737">VK_IMAGE_TYPE_2D</a>;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a912f0e8e36d47c47e5651656a9b06013">format</a> = <a class="code" href="vulkan__core_8h.html#ad61b5b94a526d0f9ae0db97072cf6b3fa7a9d563b05a75170dd5a59d0bd123169">VK_FORMAT_R8G8B8A8_UNORM</a>;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a8987da3bd3f1614dbb69a70fb3539299">extent</a> = <a class="code" href="structVkExtent3D.html">VkExtent3D</a> { width, height, 1 };</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a1ae4d9f8f412291dc7a124b715501d9b">mipLevels</a> = 1;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a844cb4fcd6af3b0f1249342a1e603b2a">arrayLayers</a> = 1;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a8771ce56c0eca0bd7e82327e244da132">samples</a> = <a class="code" href="vulkan__core_8h.html#a7972fb8a8ec7c225e60ca7c3de159706ae03a6b21b620e2c727076a3215b9f4fc">VK_SAMPLE_COUNT_1_BIT</a>;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#aa5f0d81d41a504e01c929179c568936b">tiling</a> = <a class="code" href="vulkan__core_8h.html#a5456c8cb96f58d566fb71551a93fa8f4a19590de3e4e395ab085b010d99c526b2">VK_IMAGE_TILING_OPTIMAL</a>;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#ad5d6be080490a60ced3baaa4d4643dea">usage</a> = <a class="code" href="vulkan__core_8h.html#a74802f743a6af41eb139fca85d5e7381a8fb6f8773b9f0ae2e313e19f6a2fbd52">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</a>;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a025cab2baf5b10873b054fdb6af6b851">sharingMode</a> = <a class="code" href="vulkan__core_8h.html#a18f2b8de8e276d300e9f7640d2fc1722ac5eb748579ff0bb10cc13ab135dbd109">VK_SHARING_MODE_EXCLUSIVE</a>;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a98a568e679cb0454e5378932909a835d">queueFamilyIndexCount</a> = 0;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a56bfd899a9c50ee7d45cff94517890c8">pQueueFamilyIndices</a> = 0;</div>
<div class="line">ci.<a class="code" href="structVkImageCreateInfo.html#a13d633f87608f9b3c4088a7af56d0670">initialLayout</a> = <a class="code" href="vulkan__core_8h.html#a10d9a29817e871a926df1834c7ccd88ca8c82f4974a794a28089e82451bd98445">VK_IMAGE_LAYOUT_UNDEFINED</a>;</div>
<div class="line"><a class="code" href="vulkan__core_8h.html#a55c854bd18d0ce13ffa286a17e6c1629">vkCreateImage</a>(device, &amp;ci, allocator, &amp;image));</div>
<div class="ttc" id="astructVkExtent3D_html"><div class="ttname"><a href="structVkExtent3D.html">VkExtent3D</a></div><div class="ttdef"><b>Definition:</b> vulkan_core.h:2795</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html"><div class="ttname"><a href="structVkImageCreateInfo.html">VkImageCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3366</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a01c5855fa62cd93ace4cb43d0fb7271c"><div class="ttname"><a href="structVkImageCreateInfo.html#a01c5855fa62cd93ace4cb43d0fb7271c">VkImageCreateInfo::flags</a></div><div class="ttdeci">VkImageCreateFlags flags</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3369</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a025cab2baf5b10873b054fdb6af6b851"><div class="ttname"><a href="structVkImageCreateInfo.html#a025cab2baf5b10873b054fdb6af6b851">VkImageCreateInfo::sharingMode</a></div><div class="ttdeci">VkSharingMode sharingMode</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3378</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a13d633f87608f9b3c4088a7af56d0670"><div class="ttname"><a href="structVkImageCreateInfo.html#a13d633f87608f9b3c4088a7af56d0670">VkImageCreateInfo::initialLayout</a></div><div class="ttdeci">VkImageLayout initialLayout</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3381</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a1ae4d9f8f412291dc7a124b715501d9b"><div class="ttname"><a href="structVkImageCreateInfo.html#a1ae4d9f8f412291dc7a124b715501d9b">VkImageCreateInfo::mipLevels</a></div><div class="ttdeci">uint32_t mipLevels</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3373</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a2daf972898f6f28c4bbd274f50c6d44a"><div class="ttname"><a href="structVkImageCreateInfo.html#a2daf972898f6f28c4bbd274f50c6d44a">VkImageCreateInfo::pNext</a></div><div class="ttdeci">const void * pNext</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3368</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a56bfd899a9c50ee7d45cff94517890c8"><div class="ttname"><a href="structVkImageCreateInfo.html#a56bfd899a9c50ee7d45cff94517890c8">VkImageCreateInfo::pQueueFamilyIndices</a></div><div class="ttdeci">const uint32_t * pQueueFamilyIndices</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3380</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a844cb4fcd6af3b0f1249342a1e603b2a"><div class="ttname"><a href="structVkImageCreateInfo.html#a844cb4fcd6af3b0f1249342a1e603b2a">VkImageCreateInfo::arrayLayers</a></div><div class="ttdeci">uint32_t arrayLayers</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3374</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a8771ce56c0eca0bd7e82327e244da132"><div class="ttname"><a href="structVkImageCreateInfo.html#a8771ce56c0eca0bd7e82327e244da132">VkImageCreateInfo::samples</a></div><div class="ttdeci">VkSampleCountFlagBits samples</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3375</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a8987da3bd3f1614dbb69a70fb3539299"><div class="ttname"><a href="structVkImageCreateInfo.html#a8987da3bd3f1614dbb69a70fb3539299">VkImageCreateInfo::extent</a></div><div class="ttdeci">VkExtent3D extent</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3372</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a912f0e8e36d47c47e5651656a9b06013"><div class="ttname"><a href="structVkImageCreateInfo.html#a912f0e8e36d47c47e5651656a9b06013">VkImageCreateInfo::format</a></div><div class="ttdeci">VkFormat format</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3371</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_a98a568e679cb0454e5378932909a835d"><div class="ttname"><a href="structVkImageCreateInfo.html#a98a568e679cb0454e5378932909a835d">VkImageCreateInfo::queueFamilyIndexCount</a></div><div class="ttdeci">uint32_t queueFamilyIndexCount</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3379</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_aa595c6fabd7b5f39fec5765847bf8525"><div class="ttname"><a href="structVkImageCreateInfo.html#aa595c6fabd7b5f39fec5765847bf8525">VkImageCreateInfo::imageType</a></div><div class="ttdeci">VkImageType imageType</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3370</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_aa5f0d81d41a504e01c929179c568936b"><div class="ttname"><a href="structVkImageCreateInfo.html#aa5f0d81d41a504e01c929179c568936b">VkImageCreateInfo::tiling</a></div><div class="ttdeci">VkImageTiling tiling</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3376</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_ac55852316bcd80098ac5ba7ba8f1f2e0"><div class="ttname"><a href="structVkImageCreateInfo.html#ac55852316bcd80098ac5ba7ba8f1f2e0">VkImageCreateInfo::sType</a></div><div class="ttdeci">VkStructureType sType</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3367</div></div>
<div class="ttc" id="astructVkImageCreateInfo_html_ad5d6be080490a60ced3baaa4d4643dea"><div class="ttname"><a href="structVkImageCreateInfo.html#ad5d6be080490a60ced3baaa4d4643dea">VkImageCreateInfo::usage</a></div><div class="ttdeci">VkImageUsageFlags usage</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3377</div></div>
<div class="ttc" id="avulkan__core_8h_html_a10d9a29817e871a926df1834c7ccd88ca8c82f4974a794a28089e82451bd98445"><div class="ttname"><a href="vulkan__core_8h.html#a10d9a29817e871a926df1834c7ccd88ca8c82f4974a794a28089e82451bd98445">VK_IMAGE_LAYOUT_UNDEFINED</a></div><div class="ttdeci">@ VK_IMAGE_LAYOUT_UNDEFINED</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:1283</div></div>
<div class="ttc" id="avulkan__core_8h_html_a18f2b8de8e276d300e9f7640d2fc1722ac5eb748579ff0bb10cc13ab135dbd109"><div class="ttname"><a href="vulkan__core_8h.html#a18f2b8de8e276d300e9f7640d2fc1722ac5eb748579ff0bb10cc13ab135dbd109">VK_SHARING_MODE_EXCLUSIVE</a></div><div class="ttdeci">@ VK_SHARING_MODE_EXCLUSIVE</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:1759</div></div>
<div class="ttc" id="avulkan__core_8h_html_a5456c8cb96f58d566fb71551a93fa8f4a19590de3e4e395ab085b010d99c526b2"><div class="ttname"><a href="vulkan__core_8h.html#a5456c8cb96f58d566fb71551a93fa8f4a19590de3e4e395ab085b010d99c526b2">VK_IMAGE_TILING_OPTIMAL</a></div><div class="ttdeci">@ VK_IMAGE_TILING_OPTIMAL</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:1715</div></div>
<div class="ttc" id="avulkan__core_8h_html_a55c854bd18d0ce13ffa286a17e6c1629"><div class="ttname"><a href="vulkan__core_8h.html#a55c854bd18d0ce13ffa286a17e6c1629">vkCreateImage</a></div><div class="ttdeci">VkResult vkCreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage)</div></div>
<div class="ttc" id="avulkan__core_8h_html_a74802f743a6af41eb139fca85d5e7381a8fb6f8773b9f0ae2e313e19f6a2fbd52"><div class="ttname"><a href="vulkan__core_8h.html#a74802f743a6af41eb139fca85d5e7381a8fb6f8773b9f0ae2e313e19f6a2fbd52">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</a></div><div class="ttdeci">@ VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:2299</div></div>
<div class="ttc" id="avulkan__core_8h_html_a7972fb8a8ec7c225e60ca7c3de159706ae03a6b21b620e2c727076a3215b9f4fc"><div class="ttname"><a href="vulkan__core_8h.html#a7972fb8a8ec7c225e60ca7c3de159706ae03a6b21b620e2c727076a3215b9f4fc">VK_SAMPLE_COUNT_1_BIT</a></div><div class="ttdeci">@ VK_SAMPLE_COUNT_1_BIT</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:2283</div></div>
<div class="ttc" id="avulkan__core_8h_html_aa84985704e226942ee3d767563ed17b2a334b34484fb69a5e28522a5837233737"><div class="ttname"><a href="vulkan__core_8h.html#aa84985704e226942ee3d767563ed17b2a334b34484fb69a5e28522a5837233737">VK_IMAGE_TYPE_2D</a></div><div class="ttdeci">@ VK_IMAGE_TYPE_2D</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:1723</div></div>
<div class="ttc" id="avulkan__core_8h_html_ad61b5b94a526d0f9ae0db97072cf6b3fa7a9d563b05a75170dd5a59d0bd123169"><div class="ttname"><a href="vulkan__core_8h.html#ad61b5b94a526d0f9ae0db97072cf6b3fa7a9d563b05a75170dd5a59d0bd123169">VK_FORMAT_R8G8B8A8_UNORM</a></div><div class="ttdeci">@ VK_FORMAT_R8G8B8A8_UNORM</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:1444</div></div>
<div class="ttc" id="avulkan__core_8h_html_aff9f2b99398eb80a2b5a146bc5534ce8a6c3f80c9a0267b7a8fa80ebd3344197c"><div class="ttname"><a href="vulkan__core_8h.html#aff9f2b99398eb80a2b5a146bc5534ce8a6c3f80c9a0267b7a8fa80ebd3344197c">VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</a></div><div class="ttdeci">@ VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:214</div></div>
</div><!-- fragment --><p>There are two typical issues Vulkan developers encounter when filling out a CreateInfo struct field by field</p><ul>
<li>One or more fields are left uninitialized.</li>
<li><code>sType</code> is incorrect.</li>
</ul>
<p>Especially the first one is hard to detect.</p>
<p>Vulkan-Hpp provides constructors for all CreateInfo objects which accept one parameter for each member variable. This way the compiler throws a compiler error if a value has been forgotten. In addition to this <code>sType</code> is automatically filled with the correct value and <code>pNext</code> set to a <code>nullptr</code> by default. Here's how the same code looks with a constructor:</p>
<div class="fragment"><div class="line"><a class="code" href="structvk_1_1ImageCreateInfo.html">vk::ImageCreateInfo</a> ci({}, <a class="code" href="namespacevk.html#ab2dd6e797349dbff99ae51686829325cae82a23d307975ac2e52ee0d3cbbef016">vk::ImageType::e2D</a>, <a class="code" href="namespacevk.html#aeed52badda6494849010ed8cb30bd530aaf088f4ac641369dae67c4a48a0a33ba">vk::Format::eR8G8B8A8Unorm</a>,</div>
<div class="line">                       { width, height, 1 },</div>
<div class="line">                       1, 1, <a class="code" href="namespacevk.html#a05eae8f35c965d9e0b4e3fb071ea6457acd3dc8b6cffb41e4163dcbd857ca87da">vk::SampleCountFlagBits::e1</a>,</div>
<div class="line">                       <a class="code" href="namespacevk.html#a12b12fdc89fcaac07f4fe719939db42ea4e07ab5635d43d5c329295b3ca56f1fd">vk::ImageTiling::eOptimal</a>, <a class="code" href="namespacevk.html#a68dfed262a1fe58d3fe58875254bd81ea749473a29d801c9b0187fd4931dff4d6">vk::ImageUsageFlagBits::eColorAttachment</a>,</div>
<div class="line">                       <a class="code" href="namespacevk.html#af3d89634285c9e888b107d0d869e6ad1a1540a0645b5dd31cd0c351dbe276536f">vk::SharingMode::eExclusive</a>, 0, <span class="keyword">nullptr</span>, <a class="code" href="namespacevk.html#a35fcb5ec0d960a9508e8f94851265ee4a46e5240f02f262bbbb359a08c45c083d">vk::ImageLayout::eUndefined</a>);</div>
<div class="line"><a class="code" href="classvk_1_1Image.html">vk::Image</a> image = device.createImage(ci);</div>
<div class="ttc" id="aclassvk_1_1Image_html"><div class="ttname"><a href="classvk_1_1Image.html">vk::Image</a></div><div class="ttdef"><b>Definition:</b> vulkan_handles.hpp:3651</div></div>
<div class="ttc" id="anamespacevk_html_a05eae8f35c965d9e0b4e3fb071ea6457acd3dc8b6cffb41e4163dcbd857ca87da"><div class="ttname"><a href="namespacevk.html#a05eae8f35c965d9e0b4e3fb071ea6457acd3dc8b6cffb41e4163dcbd857ca87da">vk::SampleCountFlagBits::e1</a></div><div class="ttdeci">@ e1</div></div>
<div class="ttc" id="anamespacevk_html_a12b12fdc89fcaac07f4fe719939db42ea4e07ab5635d43d5c329295b3ca56f1fd"><div class="ttname"><a href="namespacevk.html#a12b12fdc89fcaac07f4fe719939db42ea4e07ab5635d43d5c329295b3ca56f1fd">vk::ImageTiling::eOptimal</a></div><div class="ttdeci">@ eOptimal</div></div>
<div class="ttc" id="anamespacevk_html_a35fcb5ec0d960a9508e8f94851265ee4a46e5240f02f262bbbb359a08c45c083d"><div class="ttname"><a href="namespacevk.html#a35fcb5ec0d960a9508e8f94851265ee4a46e5240f02f262bbbb359a08c45c083d">vk::ImageLayout::eUndefined</a></div><div class="ttdeci">@ eUndefined</div></div>
<div class="ttc" id="anamespacevk_html_ab2dd6e797349dbff99ae51686829325cae82a23d307975ac2e52ee0d3cbbef016"><div class="ttname"><a href="namespacevk.html#ab2dd6e797349dbff99ae51686829325cae82a23d307975ac2e52ee0d3cbbef016">vk::ImageType::e2D</a></div><div class="ttdeci">@ e2D</div></div>
<div class="ttc" id="anamespacevk_html_aeed52badda6494849010ed8cb30bd530aaf088f4ac641369dae67c4a48a0a33ba"><div class="ttname"><a href="namespacevk.html#aeed52badda6494849010ed8cb30bd530aaf088f4ac641369dae67c4a48a0a33ba">vk::Format::eR8G8B8A8Unorm</a></div><div class="ttdeci">@ eR8G8B8A8Unorm</div></div>
<div class="ttc" id="anamespacevk_html_af3d89634285c9e888b107d0d869e6ad1a1540a0645b5dd31cd0c351dbe276536f"><div class="ttname"><a href="namespacevk.html#af3d89634285c9e888b107d0d869e6ad1a1540a0645b5dd31cd0c351dbe276536f">vk::SharingMode::eExclusive</a></div><div class="ttdeci">@ eExclusive</div></div>
<div class="ttc" id="astructvk_1_1ImageCreateInfo_html"><div class="ttname"><a href="structvk_1_1ImageCreateInfo.html">vk::ImageCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:29287</div></div>
</div><!-- fragment --><p>With constructors for CreateInfo structures one can also pass temporaries to Vulkan functions like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classvk_1_1Image.html">vk::Image</a> image = device.createImage({{}, <a class="code" href="namespacevk.html#ab2dd6e797349dbff99ae51686829325cae82a23d307975ac2e52ee0d3cbbef016">vk::ImageType::e2D</a>, <a class="code" href="namespacevk.html#aeed52badda6494849010ed8cb30bd530aaf088f4ac641369dae67c4a48a0a33ba">vk::Format::eR8G8B8A8Unorm</a>,</div>
<div class="line">                                     { width, height, 1 },</div>
<div class="line">                                     1, 1, <a class="code" href="namespacevk.html#a05eae8f35c965d9e0b4e3fb071ea6457acd3dc8b6cffb41e4163dcbd857ca87da">vk::SampleCountFlagBits::e1</a>,</div>
<div class="line">                                     <a class="code" href="namespacevk.html#a12b12fdc89fcaac07f4fe719939db42ea4e07ab5635d43d5c329295b3ca56f1fd">vk::ImageTiling::eOptimal</a>, <a class="code" href="namespacevk.html#a68dfed262a1fe58d3fe58875254bd81ea749473a29d801c9b0187fd4931dff4d6">vk::ImageUsageFlagBits::eColorAttachment</a>,</div>
<div class="line">                                     <a class="code" href="namespacevk.html#af3d89634285c9e888b107d0d869e6ad1a1540a0645b5dd31cd0c351dbe276536f">vk::SharingMode::eExclusive</a>, 0, <span class="keyword">nullptr</span>, <a class="code" href="namespacevk.html#a35fcb5ec0d960a9508e8f94851265ee4a46e5240f02f262bbbb359a08c45c083d">vk::ImageLayout::eUndefined</a>});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Designated Initializers</h2>
<p>Beginning with C++20, C++ supports designated initializers. As that feature requires to not have any user-declared or inherited constructors, you have to <code>#define VULKAN_HPP_NO_CONSTRUCTORS</code>, which removes all the structure and union constructors from <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>. Instead you can then use aggregate initialization. The first few vk-lines in your source might then look like </p><div class="fragment"><div class="line"><span class="comment">// initialize the vk::ApplicationInfo structure</span></div>
<div class="line"><a class="code" href="structvk_1_1ApplicationInfo.html">vk::ApplicationInfo</a> applicationInfo{ .<a class="code" href="structvk_1_1ApplicationInfo.html#a9fc0a68d6f428003a6887ff405e57a98">pApplicationName</a>   = AppName,</div>
<div class="line">                                     .applicationVersion = 1,</div>
<div class="line">                                     .pEngineName        = EngineName,</div>
<div class="line">                                     .engineVersion      = 1,</div>
<div class="line">                                     .apiVersion         = <a class="code" href="vulkan__core_8h.html#af5ccc4c7daa5f5cdc0a11e0ba70c7745">VK_API_VERSION_1_1</a> };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initialize the vk::InstanceCreateInfo</span></div>
<div class="line"><a class="code" href="structvk_1_1InstanceCreateInfo.html">vk::InstanceCreateInfo</a> instanceCreateInfo{ .<a class="code" href="structvk_1_1InstanceCreateInfo.html#a65492c5c98a26cf6bb17140807ffb068">pApplicationInfo</a> = &amp; applicationInfo };</div>
<div class="ttc" id="astructvk_1_1ApplicationInfo_html"><div class="ttname"><a href="structvk_1_1ApplicationInfo.html">vk::ApplicationInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:5476</div></div>
<div class="ttc" id="astructvk_1_1ApplicationInfo_html_a9fc0a68d6f428003a6887ff405e57a98"><div class="ttname"><a href="structvk_1_1ApplicationInfo.html#a9fc0a68d6f428003a6887ff405e57a98">vk::ApplicationInfo::pApplicationName</a></div><div class="ttdeci">const char * pApplicationName</div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:5617</div></div>
<div class="ttc" id="astructvk_1_1InstanceCreateInfo_html"><div class="ttname"><a href="structvk_1_1InstanceCreateInfo.html">vk::InstanceCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:49258</div></div>
<div class="ttc" id="astructvk_1_1InstanceCreateInfo_html_a65492c5c98a26cf6bb17140807ffb068"><div class="ttname"><a href="structvk_1_1InstanceCreateInfo.html#a65492c5c98a26cf6bb17140807ffb068">vk::InstanceCreateInfo::pApplicationInfo</a></div><div class="ttdeci">const vk::ApplicationInfo * pApplicationInfo</div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:49461</div></div>
<div class="ttc" id="avulkan__core_8h_html_af5ccc4c7daa5f5cdc0a11e0ba70c7745"><div class="ttname"><a href="vulkan__core_8h.html#af5ccc4c7daa5f5cdc0a11e0ba70c7745">VK_API_VERSION_1_1</a></div><div class="ttdeci">#define VK_API_VERSION_1_1</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:4854</div></div>
</div><!-- fragment --><p> instead of </p><div class="fragment"><div class="line"><span class="comment">// initialize the vk::ApplicationInfo structure</span></div>
<div class="line"><a class="code" href="structvk_1_1ApplicationInfo.html">vk::ApplicationInfo</a> applicationInfo( AppName, 1, EngineName, 1, <a class="code" href="vulkan__core_8h.html#af5ccc4c7daa5f5cdc0a11e0ba70c7745">VK_API_VERSION_1_1</a> );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initialize the vk::InstanceCreateInfo</span></div>
<div class="line"><a class="code" href="structvk_1_1InstanceCreateInfo.html">vk::InstanceCreateInfo</a> instanceCreateInfo( {}, &amp;applicationInfo );</div>
</div><!-- fragment --><p> Note, that the designator order needs to match the declaration order. Note as well, that now you can explicitly set the sType member of vk-structures. This is neither neccessary (as they are correctly initialized by default) nor recommended.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Passing Arrays to Functions using ArrayProxy</h2>
<p>The Vulkan API has several places where which require (count,pointer) as two function arguments and C++ has a few containers which map perfectly to this pair. To simplify development the Vulkan-Hpp bindings have replaced those argument pairs with the <code>ArrayProxy</code> template class which accepts empty arrays and a single value as well as STL containers <code>std::initializer_list</code>, <code>std::array</code> and <code>std::vector</code> as argument for construction. This way a single generated Vulkan version can accept a variety of inputs without having the combinatoric explosion which would occur when creating a function for each container type.</p>
<p>Here are some code samples on how to use the ArrayProxy:</p>
<div class="fragment"><div class="line"><a class="code" href="classvk_1_1CommandBuffer.html">vk::CommandBuffer</a> c;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// pass an empty array</span></div>
<div class="line">c.<a class="code" href="classvk_1_1CommandBuffer.html#a8633fc4d57642eaefd18b7cadca19c6b">setScissor</a>(0, <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// pass a single value. Value is passed as reference</span></div>
<div class="line"><a class="code" href="structvk_1_1Rect2D.html">vk::Rect2D</a> scissorRect = { {0, 0}, {640, 480} };</div>
<div class="line">c.<a class="code" href="classvk_1_1CommandBuffer.html#a8633fc4d57642eaefd18b7cadca19c6b">setScissor</a>(0, scissorRect);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// pass a temporary value.</span></div>
<div class="line">c.<a class="code" href="classvk_1_1CommandBuffer.html#a8633fc4d57642eaefd18b7cadca19c6b">setScissor</a>(0, { { 0, 0 },{ 640, 480 } });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// pass a fixed size array</span></div>
<div class="line"><a class="code" href="structvk_1_1Rect2D.html">vk::Rect2D</a> scissorRects[2] = { { { 0, 0 }, { 320, 240 } }, { { 320, 240 }, { 320, 240 } } };</div>
<div class="line">c.<a class="code" href="classvk_1_1CommandBuffer.html#a8633fc4d57642eaefd18b7cadca19c6b">setScissor</a>(0, scissorRects);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// generate a std::initializer_list using two rectangles from the stack. This might generate a copy of the rectangles.</span></div>
<div class="line"><a class="code" href="structvk_1_1Rect2D.html">vk::Rect2D</a> scissorRect1 = { { 0, 0 },{ 320, 240 } };</div>
<div class="line"><a class="code" href="structvk_1_1Rect2D.html">vk::Rect2D</a> scissorRect2 = { { 320, 240 },{ 320, 240 } };</div>
<div class="line">c.<a class="code" href="classvk_1_1CommandBuffer.html#a8633fc4d57642eaefd18b7cadca19c6b">setScissor</a>(0, { scissorRect, scissorRect2 });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// construct a std::initializer_list using two temporary rectangles.</span></div>
<div class="line">c.<a class="code" href="classvk_1_1CommandBuffer.html#a8633fc4d57642eaefd18b7cadca19c6b">setScissor</a>(0, { { {   0,   0 },{ 320, 240 } },</div>
<div class="line">                { { 320, 240 },{ 320, 240 } }</div>
<div class="line">}</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// pass a std::array</span></div>
<div class="line">std::array&lt;vk::Rect2D, 2&gt; arr{ scissorRect1, scissorRect2 };</div>
<div class="line">c.<a class="code" href="classvk_1_1CommandBuffer.html#a8633fc4d57642eaefd18b7cadca19c6b">setScissor</a>(0, arr);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// pass a std::vector of dynamic size</span></div>
<div class="line">std::vector&lt;vk::Rect2D&gt; vec;</div>
<div class="line">vec.push_back(scissorRect1);</div>
<div class="line">vec.push_back(scissorRect2);</div>
<div class="line">c.<a class="code" href="classvk_1_1CommandBuffer.html#a8633fc4d57642eaefd18b7cadca19c6b">setScissor</a>(0, vec);</div>
<div class="ttc" id="aclassvk_1_1CommandBuffer_html"><div class="ttname"><a href="classvk_1_1CommandBuffer.html">vk::CommandBuffer</a></div><div class="ttdef"><b>Definition:</b> vulkan_handles.hpp:4262</div></div>
<div class="ttc" id="aclassvk_1_1CommandBuffer_html_a8633fc4d57642eaefd18b7cadca19c6b"><div class="ttname"><a href="classvk_1_1CommandBuffer.html#a8633fc4d57642eaefd18b7cadca19c6b">vk::CommandBuffer::setScissor</a></div><div class="ttdeci">void setScissor(uint32_t firstScissor, uint32_t scissorCount, const vk::Rect2D *pScissors, Dispatch const &amp;d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT) const VULKAN_HPP_NOEXCEPT</div></div>
<div class="ttc" id="astructvk_1_1Rect2D_html"><div class="ttname"><a href="structvk_1_1Rect2D.html">vk::Rect2D</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:7927</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Passing Structs to Functions</h2>
<p>Vulkan-Hpp generates references for pointers to structs. This conversion allows passing temporary structs to functions which can result in shorter code. In case the input is optional and thus accepting a null pointer the parameter type will be a <code><a class="el" href="classvk_1_1Optional.html">vk::Optional</a>&lt;T&gt; const&amp;</code> type. This type accepts either a reference to <code>T</code> or nullptr as input and thus allows optional temporary structs.</p>
<div class="fragment"><div class="line"><span class="comment">// C</span></div>
<div class="line"><a class="code" href="structVkImageSubresource.html">VkImageSubresource</a> subResource;</div>
<div class="line">subResource.<a class="code" href="structVkImageSubresource.html#ad0fb37309dd78d768dad5b8f945951fe">aspectMask</a> = 0;</div>
<div class="line">subResource.<a class="code" href="structVkImageSubresource.html#ae26723a943d32237d14782ce86c27b8b">mipLevel</a> = 0;</div>
<div class="line">subResource.<a class="code" href="structVkImageSubresource.html#a1a2582770739a46c0678c934c17de095">arrayLayer</a> = 0;</div>
<div class="line"><a class="code" href="structVkSubresourceLayout.html">VkSubresourceLayout</a> layout;</div>
<div class="line"><a class="code" href="vulkan__core_8h.html#a2da028ec8c90479e56dca4d76651deaa">vkGetImageSubresourceLayout</a>(device, image, &amp;subresource, &amp;layout);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// C++</span></div>
<div class="line"><span class="keyword">auto</span> layout = device.getImageSubresourceLayout(image, { {} <span class="comment">/* flags*/</span>, 0 <span class="comment">/* miplevel */</span>, 0 <span class="comment">/* arrayLayer */</span> });</div>
<div class="ttc" id="astructVkImageSubresource_html"><div class="ttname"><a href="structVkImageSubresource.html">VkImageSubresource</a></div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3268</div></div>
<div class="ttc" id="astructVkImageSubresource_html_a1a2582770739a46c0678c934c17de095"><div class="ttname"><a href="structVkImageSubresource.html#a1a2582770739a46c0678c934c17de095">VkImageSubresource::arrayLayer</a></div><div class="ttdeci">uint32_t arrayLayer</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3271</div></div>
<div class="ttc" id="astructVkImageSubresource_html_ad0fb37309dd78d768dad5b8f945951fe"><div class="ttname"><a href="structVkImageSubresource.html#ad0fb37309dd78d768dad5b8f945951fe">VkImageSubresource::aspectMask</a></div><div class="ttdeci">VkImageAspectFlags aspectMask</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3269</div></div>
<div class="ttc" id="astructVkImageSubresource_html_ae26723a943d32237d14782ce86c27b8b"><div class="ttname"><a href="structVkImageSubresource.html#ae26723a943d32237d14782ce86c27b8b">VkImageSubresource::mipLevel</a></div><div class="ttdeci">uint32_t mipLevel</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3270</div></div>
<div class="ttc" id="astructVkSubresourceLayout_html"><div class="ttname"><a href="structVkSubresourceLayout.html">VkSubresourceLayout</a></div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3384</div></div>
<div class="ttc" id="avulkan__core_8h_html_a2da028ec8c90479e56dca4d76651deaa"><div class="ttname"><a href="vulkan__core_8h.html#a2da028ec8c90479e56dca4d76651deaa">vkGetImageSubresourceLayout</a></div><div class="ttdeci">void vkGetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
Structure Pointer Chains</h2>
<p>Vulkan allows chaining of structures through the pNext pointer. Vulkan-Hpp has a variadic template class which allows constructing of such structure chains with minimal efforts. In addition to this it checks at compile time if the spec allows the construction of such a <code>pNext</code> chain.</p>
<div class="fragment"><div class="line"><span class="comment">// This will compile successfully.</span></div>
<div class="line"><a class="code" href="classvk_1_1StructureChain.html">vk::StructureChain&lt;vk::MemoryAllocateInfo, vk::ImportMemoryFdInfoKHR&gt;</a> c;</div>
<div class="line"><a class="code" href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a> &amp;allocInfo = c.<a class="code" href="classvk_1_1StructureChain.html#a51b6c9f857ea42f21e25edab444ed8b5">get</a>&lt;<a class="code" href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a>&gt;();</div>
<div class="line"><a class="code" href="structvk_1_1ImportMemoryFdInfoKHR.html">vk::ImportMemoryFdInfoKHR</a> &amp;fdInfo = c.<a class="code" href="classvk_1_1StructureChain.html#a51b6c9f857ea42f21e25edab444ed8b5">get</a>&lt;<a class="code" href="structvk_1_1ImportMemoryFdInfoKHR.html">vk::ImportMemoryFdInfoKHR</a>&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This will fail compilation since it&#39;s not valid according to the spec.</span></div>
<div class="line"><a class="code" href="classvk_1_1StructureChain.html">vk::StructureChain&lt;vk::MemoryAllocateInfo, vk::MemoryDedicatedRequirementsKHR&gt;</a> c;</div>
<div class="line"><a class="code" href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a> &amp;allocInfo = c.<a class="code" href="classvk_1_1StructureChain.html#a51b6c9f857ea42f21e25edab444ed8b5">get</a>&lt;<a class="code" href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a>&gt;();</div>
<div class="line"><a class="code" href="structvk_1_1ImportMemoryFdInfoKHR.html">vk::ImportMemoryFdInfoKHR</a> &amp;fdInfo = c.<a class="code" href="classvk_1_1StructureChain.html#a51b6c9f857ea42f21e25edab444ed8b5">get</a>&lt;<a class="code" href="structvk_1_1ImportMemoryFdInfoKHR.html">vk::ImportMemoryFdInfoKHR</a>&gt;();</div>
<div class="ttc" id="aclassvk_1_1StructureChain_html"><div class="ttname"><a href="classvk_1_1StructureChain.html">vk::StructureChain</a></div><div class="ttdef"><b>Definition:</b> vulkan.hpp:654</div></div>
<div class="ttc" id="aclassvk_1_1StructureChain_html_a51b6c9f857ea42f21e25edab444ed8b5"><div class="ttname"><a href="classvk_1_1StructureChain.html#a51b6c9f857ea42f21e25edab444ed8b5">vk::StructureChain::get</a></div><div class="ttdeci">T &amp; get() VULKAN_HPP_NOEXCEPT</div><div class="ttdef"><b>Definition:</b> vulkan.hpp:699</div></div>
<div class="ttc" id="astructvk_1_1ImportMemoryFdInfoKHR_html"><div class="ttname"><a href="structvk_1_1ImportMemoryFdInfoKHR.html">vk::ImportMemoryFdInfoKHR</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:47078</div></div>
<div class="ttc" id="astructvk_1_1MemoryAllocateInfo_html"><div class="ttname"><a href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:50604</div></div>
</div><!-- fragment --><p>Vulkan-Hpp provides a constructor for these chains similar to the CreateInfo objects which accepts a list of all structures part of the chain. The <code>pNext</code> field is automatically set to the correct value:</p>
<div class="fragment"><div class="line"><a class="code" href="classvk_1_1StructureChain.html">vk::StructureChain&lt;vk::MemoryAllocateInfo, vk::MemoryDedicatedAllocateInfo&gt;</a> c = {</div>
<div class="line">  <a class="code" href="structvk_1_1MemoryAllocateInfo.html">vk::MemoryAllocateInfo</a>(size, type),</div>
<div class="line">  <a class="code" href="structvk_1_1MemoryDedicatedAllocateInfo.html">vk::MemoryDedicatedAllocateInfo</a>(image)</div>
<div class="line">};</div>
<div class="ttc" id="astructvk_1_1MemoryDedicatedAllocateInfo_html"><div class="ttname"><a href="structvk_1_1MemoryDedicatedAllocateInfo.html">vk::MemoryDedicatedAllocateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:50813</div></div>
</div><!-- fragment --><p>If one of the structures of a StructureChain is to be removed, maybe due to some optional settings, you can use the function <code><a class="el" href="classvk_1_1StructureChain.html#aa2cff0540ba757f6447439440297309b">vk::StructureChain::unlink</a>&lt;ClassType&gt;()</code>. It modifies the StructureChain such that the specified structure isn't part of the pNext-chain any more. Note, that the actual memory layout of the StructureChain is not modified by that function. In case that very same structure has to be re-added to the StructureChain again, use <code><a class="el" href="classvk_1_1StructureChain.html#a4c3e9f83ea357f31a3324adaf54a8778">vk::StructureChain::relink</a>&lt;ClassType&gt;()</code>.</p>
<p>Sometimes the user has to pass a preallocated structure chain to query information. For those cases there are two corresponding getter functions. One with a variadic template generating a structure chain of at least two elements to construct the return value:</p>
<div class="fragment"><div class="line"><span class="comment">// Query vk::MemoryRequirements2HR and vk::MemoryDedicatedRequirementsKHR when calling Device::getBufferMemoryRequirements2KHR:</span></div>
<div class="line"><span class="keyword">auto</span> result = device.getBufferMemoryRequirements2KHR&lt;<a class="code" href="namespacevk.html#acb472c0b4cfb4e8c81c5313d5fb01d7a">vk::MemoryRequirements2KHR</a>, <a class="code" href="structvk_1_1MemoryDedicatedRequirements.html">vk::MemoryDedicatedRequirementsKHR</a>&gt;({});</div>
<div class="line"><a class="code" href="structvk_1_1MemoryRequirements2.html">vk::MemoryRequirements2KHR</a> &amp;memReqs = result.get&lt;<a class="code" href="structvk_1_1MemoryRequirements2.html">vk::MemoryRequirements2KHR</a>&gt;();</div>
<div class="line"><a class="code" href="structvk_1_1MemoryDedicatedRequirements.html">vk::MemoryDedicatedRequirementsKHR</a> &amp;dedMemReqs = result.get&lt;<a class="code" href="structvk_1_1MemoryDedicatedRequirements.html">vk::MemoryDedicatedRequirementsKHR</a>&gt;();</div>
<div class="ttc" id="anamespacevk_html_acb472c0b4cfb4e8c81c5313d5fb01d7a"><div class="ttname"><a href="namespacevk.html#acb472c0b4cfb4e8c81c5313d5fb01d7a">vk::MemoryRequirements2KHR</a></div><div class="ttdeci">MemoryRequirements2 MemoryRequirements2KHR</div><div class="ttdef"><b>Definition:</b> vulkan_handles.hpp:167</div></div>
<div class="ttc" id="astructvk_1_1MemoryDedicatedRequirements_html"><div class="ttname"><a href="structvk_1_1MemoryDedicatedRequirements.html">vk::MemoryDedicatedRequirements</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:50921</div></div>
<div class="ttc" id="astructvk_1_1MemoryRequirements2_html"><div class="ttname"><a href="structvk_1_1MemoryRequirements2.html">vk::MemoryRequirements2</a></div><div class="ttdef"><b>Definition:</b> vulkan_structs.hpp:52180</div></div>
</div><!-- fragment --><p>To get just the base structure, without chaining, the other getter function provided does not need a template argument for the structure to get:</p>
<div class="fragment"><div class="line">// Query just vk::MemoryRequirements2KHR</div>
<div class="line">vk::MemoryRequirements2KHR memoryRequirements = device.getBufferMemoryRequirements2KHR({});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
Return values, Error Codes &amp; Exceptions</h2>
<p>By default Vulkan-Hpp has exceptions enabled. This means that Vulkan-Hpp checks the return code of each function call which returns a Vk::Result. If Vk::Result is a failure a std::runtime_error will be thrown. Since there is no need to return the error code anymore the C++ bindings can now return the actual desired return value, i.e. a vulkan handle. In those cases ResultValue &lt;SomeType&gt;::type is defined as the returned type.</p>
<p>To create a device you can now just write:</p>
<div class="fragment"><div class="line"><a class="code" href="classvk_1_1Device.html">vk::Device</a> device = physicalDevice.createDevice(createInfo);</div>
<div class="ttc" id="aclassvk_1_1Device_html"><div class="ttname"><a href="classvk_1_1Device.html">vk::Device</a></div><div class="ttdef"><b>Definition:</b> vulkan_handles.hpp:8782</div></div>
</div><!-- fragment --><p>Some functions allow more than just <code><a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa27a410c6b361732f3b4237bff6478a44">vk::Result::eSuccess</a></code> to be considered as a success code. For those functions, we always return a <code>ResultValue&lt;SomeType&gt;</code>. An example is <code>acquireNextImage2KHR</code>, that can be used like this:</p>
<div class="fragment"><div class="line"><a class="code" href="structvk_1_1ResultValue.html">vk::ResultValue&lt;uint32_t&gt;</a> result = device-&gt;<a class="code" href="classvk_1_1Device.html#a2041052e10fe5b44bc0a44e02f05e764">acquireNextImage2KHR</a>(acquireNextImageInfo);</div>
<div class="line"><span class="keywordflow">switch</span> (result.<a class="code" href="structvk_1_1ResultValue.html#afebdf14d448ee951bc385b574890704f">result</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa27a410c6b361732f3b4237bff6478a44">vk::Result::eSuccess</a>:</div>
<div class="line">        currentBuffer = result.<a class="code" href="structvk_1_1ResultValue.html#a6ca9a2905a7884f37356e266e00acc33">value</a>;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa1be2d08eb04888bcbe7642b5d9d892eb">vk::Result::eTimeout</a>:</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa263738e8a79018589c9e21d776e711ff">vk::Result::eNotReady</a>:</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfaf7de6c5e9a7662df46b60828a3980c73">vk::Result::eSuboptimalKHR</a>:</div>
<div class="line">        <span class="comment">// do something meaningful</span></div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="comment">// should not happen, as other return codes are considered to be an error and throw an exception</span></div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassvk_1_1Device_html_a2041052e10fe5b44bc0a44e02f05e764"><div class="ttname"><a href="classvk_1_1Device.html#a2041052e10fe5b44bc0a44e02f05e764">vk::Device::acquireNextImage2KHR</a></div><div class="ttdeci">VULKAN_HPP_NODISCARD Result acquireNextImage2KHR(const vk::AcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex, Dispatch const &amp;d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT) const VULKAN_HPP_NOEXCEPT</div></div>
<div class="ttc" id="anamespacevk_html_abda4f7ea9e913d7eb358776d793488dfa1be2d08eb04888bcbe7642b5d9d892eb"><div class="ttname"><a href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa1be2d08eb04888bcbe7642b5d9d892eb">vk::Result::eTimeout</a></div><div class="ttdeci">@ eTimeout</div></div>
<div class="ttc" id="anamespacevk_html_abda4f7ea9e913d7eb358776d793488dfa263738e8a79018589c9e21d776e711ff"><div class="ttname"><a href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa263738e8a79018589c9e21d776e711ff">vk::Result::eNotReady</a></div><div class="ttdeci">@ eNotReady</div></div>
<div class="ttc" id="anamespacevk_html_abda4f7ea9e913d7eb358776d793488dfa27a410c6b361732f3b4237bff6478a44"><div class="ttname"><a href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa27a410c6b361732f3b4237bff6478a44">vk::Result::eSuccess</a></div><div class="ttdeci">@ eSuccess</div></div>
<div class="ttc" id="anamespacevk_html_abda4f7ea9e913d7eb358776d793488dfaf7de6c5e9a7662df46b60828a3980c73"><div class="ttname"><a href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfaf7de6c5e9a7662df46b60828a3980c73">vk::Result::eSuboptimalKHR</a></div><div class="ttdeci">@ eSuboptimalKHR</div></div>
<div class="ttc" id="astructvk_1_1ResultValue_html"><div class="ttname"><a href="structvk_1_1ResultValue.html">vk::ResultValue</a></div><div class="ttdef"><b>Definition:</b> vulkan.hpp:6595</div></div>
<div class="ttc" id="astructvk_1_1ResultValue_html_a6ca9a2905a7884f37356e266e00acc33"><div class="ttname"><a href="structvk_1_1ResultValue.html#a6ca9a2905a7884f37356e266e00acc33">vk::ResultValue::value</a></div><div class="ttdeci">T value</div><div class="ttdef"><b>Definition:</b> vulkan.hpp:6615</div></div>
<div class="ttc" id="astructvk_1_1ResultValue_html_afebdf14d448ee951bc385b574890704f"><div class="ttname"><a href="structvk_1_1ResultValue.html#afebdf14d448ee951bc385b574890704f">vk::ResultValue::result</a></div><div class="ttdeci">Result result</div><div class="ttdef"><b>Definition:</b> vulkan.hpp:6614</div></div>
</div><!-- fragment --><p>As time passes, some vulkan functions might change, such that they start to support more result codes than <code><a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488dfa27a410c6b361732f3b4237bff6478a44">vk::Result::eSuccess</a></code> as a success code. That logical change would not be visible in the C-API, but in the C++-API, as such a function would now return a <code><a class="el" href="structvk_1_1ResultValue.html">vk::ResultValue</a>&lt;SomeType&gt;</code> instead of just <code>SomeType</code>. In such (rare) cases, you would have to adjust your cpp-sources to reflect that API change.</p>
<p>If exception handling is disabled by defining <code>VULKAN_HPP_NO_EXCEPTIONS</code> the type of <code>ResultValue&lt;SomeType&gt;::type</code> is a struct holding a <code><a class="el" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">vk::Result</a></code> and a <code>SomeType</code>. This struct supports unpacking the return values by using <code>std::tie</code>.</p>
<p>In case you dont want to use the <code><a class="el" href="classvk_1_1ArrayProxy.html">vk::ArrayProxy</a></code> and return value transformation you can still call the plain C-style function. Below are three examples showing the 3 ways to use the API:</p>
<p>The first snippet shows how to use the API without exceptions and the return value transformation:</p>
<div class="fragment"><div class="line"><span class="comment">// No exceptions, no return value transformation</span></div>
<div class="line">ShaderModuleCreateInfo createInfo(...);</div>
<div class="line">ShaderModule shader1;</div>
<div class="line"><a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">Result</a> result = device.<a class="code" href="classvk_1_1Device.html#a1351d4ec8eefa666404dbcf30bd5ccdd">createShaderModule</a>(&amp;createInfo, allocator, &amp;shader1);</div>
<div class="line"><span class="keywordflow">if</span> (result.result != <a class="code" href="vulkan__core_8h.html#abe3614d1bd40772bc2398a4a86ea4a45a3671aecac45b2f102cbe941e2ed4d32a">VK_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    handle error code;</div>
<div class="line">    cleanup?</div>
<div class="line">    <span class="keywordflow">return</span>?</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">ShaderModule shader2;</div>
<div class="line"><a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">Result</a> result = device.<a class="code" href="classvk_1_1Device.html#a1351d4ec8eefa666404dbcf30bd5ccdd">createShaderModule</a>(&amp;createInfo, allocator, &amp;shader2);</div>
<div class="line"><span class="keywordflow">if</span> (result != <a class="code" href="vulkan__core_8h.html#abe3614d1bd40772bc2398a4a86ea4a45a3671aecac45b2f102cbe941e2ed4d32a">VK_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    handle error code;</div>
<div class="line">    cleanup?</div>
<div class="line">    <span class="keywordflow">return</span>?</div>
<div class="line">}</div>
<div class="ttc" id="aclassvk_1_1Device_html_a1351d4ec8eefa666404dbcf30bd5ccdd"><div class="ttname"><a href="classvk_1_1Device.html#a1351d4ec8eefa666404dbcf30bd5ccdd">vk::Device::createShaderModule</a></div><div class="ttdeci">VULKAN_HPP_NODISCARD Result createShaderModule(const vk::ShaderModuleCreateInfo *pCreateInfo, const vk::AllocationCallbacks *pAllocator, vk::ShaderModule *pShaderModule, Dispatch const &amp;d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT) const VULKAN_HPP_NOEXCEPT</div></div>
<div class="ttc" id="anamespacevk_html_abda4f7ea9e913d7eb358776d793488df"><div class="ttname"><a href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">vk::Result</a></div><div class="ttdeci">Result</div><div class="ttdef"><b>Definition:</b> vulkan_enums.hpp:231</div></div>
<div class="ttc" id="avulkan__core_8h_html_abe3614d1bd40772bc2398a4a86ea4a45a3671aecac45b2f102cbe941e2ed4d32a"><div class="ttname"><a href="vulkan__core_8h.html#abe3614d1bd40772bc2398a4a86ea4a45a3671aecac45b2f102cbe941e2ed4d32a">VK_SUCCESS</a></div><div class="ttdeci">@ VK_SUCCESS</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:141</div></div>
</div><!-- fragment --><p>The second snippet shows how to use the API using return value transformation, but without exceptions. Its already a little bit shorter than the original code:</p>
<div class="fragment"><div class="line">ResultValue&lt;ShaderModule&gt; shaderResult1 = device.<a class="code" href="classvk_1_1Device.html#a1351d4ec8eefa666404dbcf30bd5ccdd">createShaderModule</a>({...} <span class="comment">/* createInfo temporary */</span>);</div>
<div class="line"><span class="keywordflow">if</span> (shaderResult1.result != <a class="code" href="vulkan__core_8h.html#abe3614d1bd40772bc2398a4a86ea4a45a3671aecac45b2f102cbe941e2ed4d32a">VK_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">  handle error code;</div>
<div class="line">  cleanup?</div>
<div class="line">  <span class="keywordflow">return</span>?</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// std::tie support.</span></div>
<div class="line"><a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">vk::Result</a> result;</div>
<div class="line"><a class="code" href="classvk_1_1ShaderModule.html">vk::ShaderModule</a> shaderModule2;</div>
<div class="line">std::tie(result, shaderModule2)  = device.<a class="code" href="classvk_1_1Device.html#a1351d4ec8eefa666404dbcf30bd5ccdd">createShaderModule</a>({...} <span class="comment">/* createInfo temporary */</span>);</div>
<div class="line"><span class="keywordflow">if</span> (result != <a class="code" href="vulkan__core_8h.html#abe3614d1bd40772bc2398a4a86ea4a45a3671aecac45b2f102cbe941e2ed4d32a">VK_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">  handle error code;</div>
<div class="line">  cleanup?</div>
<div class="line">  <span class="keywordflow">return</span>?</div>
<div class="line">}</div>
<div class="ttc" id="aclassvk_1_1ShaderModule_html"><div class="ttname"><a href="classvk_1_1ShaderModule.html">vk::ShaderModule</a></div><div class="ttdef"><b>Definition:</b> vulkan_handles.hpp:8277</div></div>
</div><!-- fragment --><p>A nicer way to unpack the result is provided by the structured bindings of C++17. They will allow us to get the result with a single line of code:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [result, shaderModule2] = device.<a class="code" href="classvk_1_1Device.html#a1351d4ec8eefa666404dbcf30bd5ccdd">createShaderModule</a>({...} <span class="comment">/* createInfo temporary */</span>);</div>
</div><!-- fragment --><p>Finally, the last code example is using exceptions and return value transformation. This is the default mode of the API.</p>
<div class="fragment"><div class="line">ShaderModule shader1;</div>
<div class="line">ShaderModule shader2;</div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  shader1 = device.<a class="code" href="classvk_1_1Device.html#a1351d4ec8eefa666404dbcf30bd5ccdd">createShaderModule</a>({...});</div>
<div class="line">  shader2 = device.<a class="code" href="classvk_1_1Device.html#a1351d4ec8eefa666404dbcf30bd5ccdd">createShaderModule</a>({...});</div>
<div class="line">} <span class="keywordflow">catch</span>(std::exception <span class="keyword">const</span> &amp;e) {</div>
<div class="line">  <span class="comment">// handle error and free resources</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Keep in mind that Vulkan-Hpp does not support RAII style handles and that you have to cleanup your resources in the error handler!</p>
<h2><a class="anchor" id="autotoc_md20"></a>
C++17: [[nodiscard]]</h2>
<p>With C++17 and above, some functions are attributed with [[nodiscard]], resulting in a warning if you don't use the return value in any way. You can switch those warnings off by defining VULKAN_HPP_NO_NODISCARD_WARNINGS.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Enumerations</h2>
<p>For the return value transformation, there's one special class of return values which require special handling: Enumerations. For enumerations you usually have to write code like this:</p>
<div class="fragment"><div class="line">std::vector&lt;LayerProperties,Allocator&gt; properties;</div>
<div class="line">uint32_t propertyCount;</div>
<div class="line"><a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">Result</a> result;</div>
<div class="line"><span class="keywordflow">do</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// determine number of elements to query</span></div>
<div class="line">  result = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">Result</a><span class="keyword">&gt;</span>( vk::enumerateDeviceLayerProperties( m_physicalDevice, &amp;propertyCount, <span class="keyword">nullptr</span> ) );</div>
<div class="line">  <span class="keywordflow">if</span> ( ( result == Result::eSuccess ) &amp;&amp; propertyCount )</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// allocate memory &amp; query again</span></div>
<div class="line">    properties.resize( propertyCount );</div>
<div class="line">    result = <span class="keyword">static_cast&lt;</span><a class="code" href="namespacevk.html#abda4f7ea9e913d7eb358776d793488df">Result</a><span class="keyword">&gt;</span>( vk::enumerateDeviceLayerProperties( m_physicalDevice, &amp;propertyCount, reinterpret_cast</div>
<div class="line">     &lt;<a class="code" href="structVkLayerProperties.html">VkLayerProperties</a>*&gt;( properties.data() ) ) );</div>
<div class="line">  }</div>
<div class="line">} <span class="keywordflow">while</span> ( result == Result::eIncomplete );</div>
<div class="line"><span class="comment">// it&#39;s possible that the count has changed, start again if properties was not big enough</span></div>
<div class="line">properties.resize(propertyCount);</div>
<div class="ttc" id="astructVkLayerProperties_html"><div class="ttname"><a href="structVkLayerProperties.html">VkLayerProperties</a></div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3208</div></div>
</div><!-- fragment --><p>Since writing this loop over and over again is tedious and error prone the C++ binding takes care of the enumeration so that you can just write:</p>
<div class="fragment"><div class="line">std::vector&lt;LayerProperties&gt; properties = physicalDevice.enumerateDeviceLayerProperties();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md22"></a>
UniqueHandle for automatic resource management</h2>
<p>Vulkan-Hpp provides a <code><a class="el" href="classvk_1_1UniqueHandle.html">vk::UniqueHandle</a>&lt;Type, Deleter&gt;</code> interface. For each Vulkan handle type <code>vk::Type</code> there is a unique handle <code>vk::UniqueType</code> which will delete the underlying Vulkan resource upon destruction, e.g. <code><a class="el" href="namespacevk.html#a6381fb8fdaf8510202e7eac8023d611c">vk::UniqueBuffer</a></code> is the unique handle for <code><a class="el" href="classvk_1_1Buffer.html">vk::Buffer</a></code>.</p>
<p>For each function which constructs a Vulkan handle of type <code>vk::Type</code> Vulkan-Hpp provides a second version which returns a <code>vk::UniqueType</code>. E.g. for <code><a class="el" href="classvk_1_1Device.html#a9e0ccc62689960bb2e69f8876ae9d777">vk::Device::createBuffer</a></code> there is <code><a class="el" href="classvk_1_1Device.html#ae35d1881c06eca713cced469a172dde1">vk::Device::createBufferUnique</a></code> and for <code>vk::allocateCommandBuffers</code> there is <code>vk::allocateCommandBuffersUnique</code>.</p>
<p>Note that using <code><a class="el" href="classvk_1_1UniqueHandle.html">vk::UniqueHandle</a></code> comes at a cost since most deleters have to store the <code><a class="el" href="structvk_1_1AllocationCallbacks.html">vk::AllocationCallbacks</a></code> and parent handle used for construction because they are required for automatic destruction.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
SharedHandle</h2>
<p>Vulkan-Hpp provides a <code>vk::SharedHandle&lt;Type&gt;</code> interface. For each Vulkan handle type <code>vk::Type</code> there is a shared handle <code>vk::SharedType</code> which will delete the underlying Vulkan resource upon destruction, e.g. <code>vk::SharedBuffer</code> is the shared handle for <code><a class="el" href="classvk_1_1Buffer.html">vk::Buffer</a></code>.</p>
<p>Unlike UniqueHandle, SharedHandle takes shared ownership of the resource as well as its parent. This means that parent handle will not be destroyed until all child resources are deleted. This is useful for resources that are shared between multiple threads or objects.</p>
<p>This mechanism ensures correct destruction order even if the parent SharedHandle is destroyed before its child handle. Otherwise, the handle behaves like <code>std::shared_ptr</code>. <code>vk::SharedInstance</code> or any of its child object should be last to delete (first created, first in class declaration)</p>
<p>There are no functions which return a <code>vk::SharedHandle</code> directly yet. Instead, you can construct a <code>vk::SharedHandle</code> from a <code>vk::Handle</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classvk_1_1Buffer.html">vk::Buffer</a> buffer = device.<a class="code" href="classvk_1_1Device.html#a9e0ccc62689960bb2e69f8876ae9d777">createBuffer</a>(...);</div>
<div class="line">vk::SharedBuffer sharedBuffer(buffer, device); <span class="comment">// sharedBuffer now owns the buffer</span></div>
<div class="ttc" id="aclassvk_1_1Buffer_html"><div class="ttname"><a href="classvk_1_1Buffer.html">vk::Buffer</a></div><div class="ttdef"><b>Definition:</b> vulkan_handles.hpp:3135</div></div>
<div class="ttc" id="aclassvk_1_1Device_html_a9e0ccc62689960bb2e69f8876ae9d777"><div class="ttname"><a href="classvk_1_1Device.html#a9e0ccc62689960bb2e69f8876ae9d777">vk::Device::createBuffer</a></div><div class="ttdeci">VULKAN_HPP_NODISCARD Result createBuffer(const vk::BufferCreateInfo *pCreateInfo, const vk::AllocationCallbacks *pAllocator, vk::Buffer *pBuffer, Dispatch const &amp;d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT) const VULKAN_HPP_NOEXCEPT</div></div>
</div><!-- fragment --><p>There are several specializations of <code>vk::SharedHandle</code> for different handle types. For example, <code>vk::SharedImage</code> may take an additional argument to specify if the image is owned by swapchain:</p>
<div class="fragment"><div class="line"><a class="code" href="classvk_1_1Image.html">vk::Image</a> image = swapchain.getImages(...)[0]; <span class="comment">// get the first image from the swapchain</span></div>
<div class="line">vk::SharedImage sharedImage(image, device, SwapChainOwns::yes); <span class="comment">// sharedImage now owns the image, but won&#39;t destroy it</span></div>
</div><!-- fragment --><p>There is also a specialization for <code><a class="el" href="classvk_1_1SwapchainKHR.html">vk::SwapchainKHR</a></code> which takes an additional argument to specify a surface:</p>
<div class="fragment"><div class="line"><a class="code" href="classvk_1_1SwapchainKHR.html">vk::SwapchainKHR</a> swapchain = device.<a class="code" href="classvk_1_1Device.html#ad0e1614f3ddb046ecf48b0be93145367">createSwapchainKHR</a>(...);</div>
<div class="line">vk::SharedSwapchainKHR sharedSwapchain(swapchain, device, surface); <span class="comment">// sharedSwapchain now owns the swapchain and surface</span></div>
<div class="ttc" id="aclassvk_1_1Device_html_ad0e1614f3ddb046ecf48b0be93145367"><div class="ttname"><a href="classvk_1_1Device.html#ad0e1614f3ddb046ecf48b0be93145367">vk::Device::createSwapchainKHR</a></div><div class="ttdeci">VULKAN_HPP_NODISCARD Result createSwapchainKHR(const vk::SwapchainCreateInfoKHR *pCreateInfo, const vk::AllocationCallbacks *pAllocator, vk::SwapchainKHR *pSwapchain, Dispatch const &amp;d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT) const VULKAN_HPP_NOEXCEPT</div></div>
<div class="ttc" id="aclassvk_1_1SwapchainKHR_html"><div class="ttname"><a href="classvk_1_1SwapchainKHR.html">vk::SwapchainKHR</a></div><div class="ttdef"><b>Definition:</b> vulkan_handles.hpp:2703</div></div>
</div><!-- fragment --><p>You can create a <code>vk::SharedHandle</code> overload for your own handle type or own shared handles by providing several template arguments to SharedHandleBase:</p><ul>
<li>A handle type</li>
<li>A parent handle type or a header structure, that contains parent</li>
<li>A class itself for CRTP</li>
</ul>
<p>With this, provide a custom static destruction function <code>internalDestroy</code>, that takes in a parent handle and a handle to destroy. Don't forget to add a friend declaration for the base class.</p>
<div class="fragment"><div class="line"><span class="comment">// Example of a custom shared device, that takes in an instance as a parent</span></div>
<div class="line"><span class="keyword">class </span>shared_handle&lt;<a class="code" href="vulkan__core_8h.html#a6e9c08f343cc1f9bd6f7d4a3ddbc3442">VkDevice</a>&gt; : <span class="keyword">public</span> vk::SharedHandleBase&lt;VkDevice, vk::SharedInstance, shared_handle&lt;VkDevice&gt;&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> base = vk::SharedHandleBase&lt;VkDevice, vk::SharedInstance, shared_handle&lt;VkDevice&gt;&gt;;</div>
<div class="line">    <span class="keyword">friend</span> base;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    shared_handle() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">explicit</span> shared_handle(<a class="code" href="vulkan__core_8h.html#a6e9c08f343cc1f9bd6f7d4a3ddbc3442">VkDevice</a> handle, vk::SharedInstance parent) noexcept</div>
<div class="line">        : base(handle, std::move(parent)) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; getParent() const noexcept {</div>
<div class="line">        <span class="keywordflow">return</span> getHeader();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> internalDestroy(<span class="keyword">const</span> vk::SharedInstance&amp; <span class="comment">/*control*/</span>, <a class="code" href="vulkan__core_8h.html#a6e9c08f343cc1f9bd6f7d4a3ddbc3442">VkDevice</a> handle) noexcept {</div>
<div class="line">        <a class="code" href="vulkan__core_8h.html#a955319f35ad2f26ea9f80c44ab534cac">vkDestroyDevice</a>(handle);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="avulkan__core_8h_html_a6e9c08f343cc1f9bd6f7d4a3ddbc3442"><div class="ttname"><a href="vulkan__core_8h.html#a6e9c08f343cc1f9bd6f7d4a3ddbc3442">VkDevice</a></div><div class="ttdeci">struct VkDevice_T * VkDevice</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:103</div></div>
<div class="ttc" id="avulkan__core_8h_html_a955319f35ad2f26ea9f80c44ab534cac"><div class="ttname"><a href="vulkan__core_8h.html#a955319f35ad2f26ea9f80c44ab534cac">vkDestroyDevice</a></div><div class="ttdeci">void vkDestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator)</div></div>
</div><!-- fragment --><p>The API will be extended to provide creation functions in the future.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
Custom allocators</h2>
<p>Sometimes it is required to use <code>std::vector</code> with custom allocators. Vulkan-Hpp supports vectors with custom allocators as input for <code><a class="el" href="classvk_1_1ArrayProxy.html">vk::ArrayProxy</a></code> and for functions which do return a vector. For the latter case, add your favorite custom allocator as template argument to the function call like this:</p>
<div class="fragment"><div class="line">std::vector&lt;LayerProperties, MyCustomAllocator&gt; properties = physicalDevice.enumerateDeviceLayerProperties&lt;MyCustomAllocator&gt;();</div>
</div><!-- fragment --><p>You can as well use a stateful custom allocator by providing it as an argument to those functions. Unfortunately, to make the compilers happy, you also need to explicitly set the Dispatch argument. To get the default there, a simple <code>{}</code> would suffice:</p>
<div class="fragment"><div class="line">MyStatefulCustomAllocator allocator;</div>
<div class="line">std::vector&lt;LayerProperties, MyStatefulCustomAllocator&gt; properties = physicalDevice.enumerateDeviceLayerProperties( allocator, {} );</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md25"></a>
Custom assertions</h2>
<p>All over <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>, there are a couple of calls to an assert function. By defining <code>VULKAN_HPP_ASSERT</code>, you can specifiy your own custom assert function to be called instead.</p>
<p>By default, <code>VULKAN_HPP_ASSERT_ON_RESULT</code> will be used for checking results when <code>VULKAN_HPP_NO_EXCEPTIONS</code> is defined. If you want to handle errors by yourself, you can disable/customize it just like <code>VULKAN_HPP_ASSERT</code>.</p>
<p>There are a couple of static assertions for each handle class and each struct in the file <a class="el" href="vulkan__static__assertions_8hpp.html">vulkan_static_assertions.hpp</a>. You might include that file in at least one of your source files. By defining <code>VULKAN_HPP_STATIC_ASSERT</code>, you can specify your own custom static assertion to be used for those cases. That is, by defining it to be a NOP, you can reduce your compilation time a little.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Extensions / Per Device function pointers</h2>
<p>The Vulkan loader exposes only the Vulkan core functions and a limited number of extensions. To use Vulkan-Hpp with extensions it's required to have either a library which provides stubs to all used Vulkan functions or to tell Vulkan-Hpp to dispatch those functions pointers. Vulkan-Hpp provides a per-function dispatch mechanism by accepting a dispatch class as last parameter in each function call. The dispatch class must provide a callable type for each used Vulkan function. Vulkan-Hpp provides one implementation, <code>DispatchLoaderDynamic</code>, which fetches all function pointers known to the library.</p>
<div class="fragment"><div class="line"><span class="comment">// Providing a function pointer resolving vkGetInstanceProcAddr, just the few functions not depending an an instance or a device are fetched</span></div>
<div class="line"><a class="code" href="classvk_1_1DispatchLoaderDynamic.html">vk::DispatchLoaderDynamic</a> dld( getInstanceProcAddr );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Providing an already created VkInstance and a function pointer resolving vkGetInstanceProcAddr, all functions are fetched</span></div>
<div class="line"><a class="code" href="classvk_1_1DispatchLoaderDynamic.html">vk::DispatchLoaderDynamic</a> dldi( instance, getInstanceProcAddr );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Providing also an already created VkDevice and optionally a function pointer resolving vkGetDeviceProcAddr, all functions are fetched as well, but now device-specific functions are fetched via vkDeviceGetProcAddr.</span></div>
<div class="line"><a class="code" href="classvk_1_1DispatchLoaderDynamic.html">vk::DispatchLoaderDynamic</a> dldid( instance, getInstanceProcAddr, device );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Pass dispatch class to function call as last parameter</span></div>
<div class="line">device.<a class="code" href="classvk_1_1Device.html#ac5dadd8a552b5f67a068219381de9550">getQueue</a>(graphics_queue_family_index, 0, &amp;graphics_queue, dldid);</div>
<div class="ttc" id="aclassvk_1_1Device_html_ac5dadd8a552b5f67a068219381de9550"><div class="ttname"><a href="classvk_1_1Device.html#ac5dadd8a552b5f67a068219381de9550">vk::Device::getQueue</a></div><div class="ttdeci">void getQueue(uint32_t queueFamilyIndex, uint32_t queueIndex, vk::Queue *pQueue, Dispatch const &amp;d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT) const VULKAN_HPP_NOEXCEPT</div></div>
<div class="ttc" id="aclassvk_1_1DispatchLoaderDynamic_html"><div class="ttname"><a href="classvk_1_1DispatchLoaderDynamic.html">vk::DispatchLoaderDynamic</a></div><div class="ttdef"><b>Definition:</b> vulkan.hpp:16392</div></div>
</div><!-- fragment --><p>To use the <code><a class="el" href="classvk_1_1DispatchLoaderDynamic.html">vk::DispatchLoaderDynamic</a></code> as the default dispatcher (means: you don't need to explicitly add it to every function call), you need to <code>#define VULKAN_HPP_DISPATCH_LOADER_DYNAMIC 1</code>, and have the macro <code>VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE</code> exactly once in your source code to provide storage for that default dispatcher. Then you can use it by the macro <code>VULKAN_HPP_DEFAULT_DISPATCHER</code>, as is shown in the code snippets below. Creating a full featured <code><a class="el" href="classvk_1_1DispatchLoaderDynamic.html">vk::DispatchLoaderDynamic</a></code> is a two- to three-step process, where you have three choices for the first step:</p><ol type="1">
<li>Before any call into a vk-function you need to initialize the dynamic dispatcher by one of three methods</li>
</ol>
<ul>
<li>Let Vulkan-Hpp do all the work by internally using a little helper class <code>vk::DynamicLoader</code>: <div class="fragment"><div class="line"><a class="code" href="vulkan__hpp__macros_8hpp.html#a2a931d9beee1ecf03437ad812f4e5510">VULKAN_HPP_DEFAULT_DISPATCHER</a>.init();</div>
<div class="ttc" id="avulkan__hpp__macros_8hpp_html_a2a931d9beee1ecf03437ad812f4e5510"><div class="ttname"><a href="vulkan__hpp__macros_8hpp.html#a2a931d9beee1ecf03437ad812f4e5510">VULKAN_HPP_DEFAULT_DISPATCHER</a></div><div class="ttdeci">#define VULKAN_HPP_DEFAULT_DISPATCHER</div><div class="ttdef"><b>Definition:</b> vulkan_hpp_macros.hpp:257</div></div>
</div><!-- fragment --></li>
<li>Use your own dynamic loader, which just needs to provide a templated function <code>getProcAddress</code> (compare with <code>vk::DynamicLoader</code> in <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>): <div class="fragment"><div class="line">YourDynamicLoader ydl;</div>
<div class="line"><a class="code" href="vulkan__hpp__macros_8hpp.html#a2a931d9beee1ecf03437ad812f4e5510">VULKAN_HPP_DEFAULT_DISPATCHER</a>.init(ydl);</div>
</div><!-- fragment --> Note that you need to keep that dynamic loader object alive until after the last call to a vulkan function in your program. For example by making it static, or storing it somewhere globally.</li>
<li>Use your own initial function pointer of type PFN_vkGetInstanceProcAddr: <div class="fragment"><div class="line"><a class="code" href="vulkan__core_8h.html#a80db697d393fca3155bdbfebe48efa09">PFN_vkGetInstanceProcAddr</a> <a class="code" href="vulkan__core_8h.html#a2d169a3fe7e208c72abbeb1ed3675940">vkGetInstanceProcAddr</a> = your_own_function_pointer_getter();</div>
<div class="line"><a class="code" href="vulkan__hpp__macros_8hpp.html#a2a931d9beee1ecf03437ad812f4e5510">VULKAN_HPP_DEFAULT_DISPATCHER</a>.init(<a class="code" href="vulkan__core_8h.html#a2d169a3fe7e208c72abbeb1ed3675940">vkGetInstanceProcAddr</a>);</div>
<div class="ttc" id="avulkan__core_8h_html_a2d169a3fe7e208c72abbeb1ed3675940"><div class="ttname"><a href="vulkan__core_8h.html#a2d169a3fe7e208c72abbeb1ed3675940">vkGetInstanceProcAddr</a></div><div class="ttdeci">PFN_vkVoidFunction vkGetInstanceProcAddr(VkInstance instance, const char *pName)</div></div>
<div class="ttc" id="avulkan__core_8h_html_a80db697d393fca3155bdbfebe48efa09"><div class="ttname"><a href="vulkan__core_8h.html#a80db697d393fca3155bdbfebe48efa09">PFN_vkGetInstanceProcAddr</a></div><div class="ttdeci">PFN_vkVoidFunction(* PFN_vkGetInstanceProcAddr)(VkInstance instance, const char *pName)</div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3922</div></div>
</div><!-- fragment --></li>
</ul>
<ol type="1">
<li>initialize it with a <a class="el" href="classvk_1_1Instance.html">vk::Instance</a> to get all the other function pointers: <div class="fragment"><div class="line"><a class="code" href="classvk_1_1Instance.html">vk::Instance</a> instance = <a class="code" href="namespacevk.html#ab34f5579e7a4133f2bc5c0c25bba6ab0">vk::createInstance</a>({}, <span class="keyword">nullptr</span>);</div>
<div class="line"><a class="code" href="vulkan__hpp__macros_8hpp.html#a2a931d9beee1ecf03437ad812f4e5510">VULKAN_HPP_DEFAULT_DISPATCHER</a>.init(instance);</div>
<div class="ttc" id="aclassvk_1_1Instance_html"><div class="ttname"><a href="classvk_1_1Instance.html">vk::Instance</a></div><div class="ttdef"><b>Definition:</b> vulkan_handles.hpp:15429</div></div>
<div class="ttc" id="anamespacevk_html_ab34f5579e7a4133f2bc5c0c25bba6ab0"><div class="ttname"><a href="namespacevk.html#ab34f5579e7a4133f2bc5c0c25bba6ab0">vk::createInstance</a></div><div class="ttdeci">VULKAN_HPP_NODISCARD VULKAN_HPP_INLINE Result createInstance(const vk::InstanceCreateInfo *pCreateInfo, const vk::AllocationCallbacks *pAllocator, vk::Instance *pInstance, Dispatch const &amp;d) VULKAN_HPP_NOEXCEPT</div><div class="ttdef"><b>Definition:</b> vulkan_funcs.hpp:21</div></div>
</div><!-- fragment --></li>
<li>optionally initialize it with a <a class="el" href="classvk_1_1Device.html">vk::Device</a> to get device-specific function pointers <div class="fragment"><div class="line">std::vector&lt;vk::PhysicalDevice&gt; physicalDevices = instance.<a class="code" href="classvk_1_1Instance.html#a5955e65fd7627b59155ed0134f3e241d">enumeratePhysicalDevices</a>();</div>
<div class="line">assert(!physicalDevices.empty());</div>
<div class="line"><a class="code" href="classvk_1_1Device.html">vk::Device</a> device = physicalDevices[0].createDevice({}, <span class="keyword">nullptr</span>);</div>
<div class="line"><a class="code" href="vulkan__hpp__macros_8hpp.html#a2a931d9beee1ecf03437ad812f4e5510">VULKAN_HPP_DEFAULT_DISPATCHER</a>.init(device);</div>
<div class="ttc" id="aclassvk_1_1Instance_html_a5955e65fd7627b59155ed0134f3e241d"><div class="ttname"><a href="classvk_1_1Instance.html#a5955e65fd7627b59155ed0134f3e241d">vk::Instance::enumeratePhysicalDevices</a></div><div class="ttdeci">VULKAN_HPP_NODISCARD Result enumeratePhysicalDevices(uint32_t *pPhysicalDeviceCount, vk::PhysicalDevice *pPhysicalDevices, Dispatch const &amp;d VULKAN_HPP_DEFAULT_DISPATCHER_ASSIGNMENT) const VULKAN_HPP_NOEXCEPT</div></div>
</div><!-- fragment --> After the second step above, the dispatcher is fully functional. Adding the third step can potentially result in more efficient code. But if you intend to use multiple devices, you could just omit that third step and let the driver do the device-dispatching.</li>
</ol>
<p>In some cases the storage for the DispatchLoaderDynamic should be embedded in a DLL. For those cases you need to define <code>VULKAN_HPP_STORAGE_SHARED</code> to tell Vulkan-Hpp that the storage resides in a DLL. When compiling the DLL with the storage it is also required to define <code>VULKAN_HPP_STORAGE_SHARED_EXPORT</code> to export the required symbols.</p>
<p>For all functions, that VULKAN_HPP_DEFAULT_DISPATCHER is the default for the last argument to that function. In case you want to explicitly provide the dispatcher for each and every function call (when you have multiple dispatchers for different devices, for example) and you want to make sure, that you don't accidentally miss any function call, you can define VULKAN_HPP_NO_DEFAULT_DISPATCHER before you include <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> to remove that default argument.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Type traits</h2>
<p><a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> provides a couple of type traits, easing template programming:</p><ul>
<li><code>template &lt;typename EnumType, EnumType value&gt; struct CppType</code> Maps <code>IndexType</code> values (<code>IndexType::eUint16</code>, <code>IndexType::eUint32</code>, ...) to the corresponding type (<code>uint16_t</code>, <code>uint32_t</code>, ...) by the member type <code>Type</code>; Maps <code>ObjectType</code> values (<code>ObjectType::eInstance</code>, <code>ObjectType::eDevice</code>, ...) to the corresponding type (<code><a class="el" href="classvk_1_1Instance.html">vk::Instance</a></code>, <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code>, ...) by the member type <code>Type</code>; Maps <code>DebugReportObjectType</code> values (<code>DebugReportObjectTypeEXT::eInstance</code>, <code>DebugReportObjectTypeEXT::eDevice</code>, ...) to the corresponding type (<code><a class="el" href="classvk_1_1Instance.html">vk::Instance</a></code>, <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code>, ...) by the member type <code>Type</code>;</li>
<li><code>template &lt;typename T&gt; struct IndexTypeValue</code> Maps scalar types (<code>uint16_t</code>, <code>uint32_t</code>, ...) to the corresponding <code>IndexType</code> value (<code>IndexType::eUint16</code>, <code>IndexType::eUint3</code>2, ...).</li>
<li><code>template &lt;typename T&gt; struct isVulkanHandleType</code> Maps a type to <code>true</code> if and only if it's a handle class (<code><a class="el" href="classvk_1_1Instance.html">vk::Instance</a></code>, <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code>, ...) by the static member <code>value</code>.</li>
<li><code>HandleClass::CType</code> Maps a handle class (<code><a class="el" href="classvk_1_1Instance.html">vk::Instance</a></code>, <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code>, ...) to the corresponding C-type (<code>VkInstance</code>, <code>VkDevice</code>, ...) by the member type <code>CType</code>.</li>
<li><code>HandleClass::objectType</code> Maps a handle class (<code><a class="el" href="classvk_1_1Instance.html">vk::Instance</a></code>, <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code>, ...) to the corresponding <code>ObjectType</code> value (<code>ObjectType::eInstance</code>, <code>ObjectType::eDevice</code>, ...) by the static member <code>objectType</code>.</li>
<li><code>HandleClass::debugReportObjectType</code> Maps a handle class (<code><a class="el" href="classvk_1_1Instance.html">vk::Instance</a></code>, <code><a class="el" href="classvk_1_1Device.html">vk::Device</a></code>, ...) to the corresponding <code>DebugReportObjectTypeEXT</code> value (<code>DebugReportObjectTypeEXT::eInstance</code>, <code>DebugReportObjectTypeEXT::eDevice</code>, ...) by the static member <code>debugReportObjectType</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
vk::Format trait functions</h2>
<p>With the additional header <code><a class="el" href="vulkan__format__traits_8hpp.html">vulkan_format_traits.hpp</a></code>, a couple of trait functions on <code><a class="el" href="namespacevk.html#aeed52badda6494849010ed8cb30bd530">vk::Format</a></code> are provided. With C++14 and above, all those functions are marked as <code>constexpr</code>, that is with appropriate arguments, they are resolved by the compiler.</p><ul>
<li><code>uin8_t blockSize( vk::Format format );</code> Gets the texel block size of this format in bytes.</li>
<li><code>uint8_t texelsPerBlock( vk::Format format );</code> Gets the number of texels in a texel block.</li>
<li><code>std::array&lt;uint8_t, 3&gt; blockExtent( vk::Format format );</code> Gets the three-dimensional extent of texel blocks.</li>
<li><code>char const * compressionScheme( vk::Format format );</code> Gets a textual description of the compression scheme of this format, or an empty text if it is not compressed.</li>
<li><code>bool isCompressed( vk::Format format );</code> True, if format is a compressed format, otherwise false.</li>
<li><code>uint8_t packed( vk::Format format );</code> Gets the number of bits into which the format is packed. A single image element in this format can be stored in the same space as a scalar type of this bit width.</li>
<li><code>uint8_t componentCount( vk::Format format );</code> Gets the number of components of this format.</li>
<li><code>bool componentsAreCompressed( vk::Format format );</code> True, if the components of this format are compressed, otherwise False.</li>
<li><code>uint8_t componentBits( vk::Format format, uint8_t component );</code> Gets the number of bits in this component, if not compressed, otherwise 0.</li>
<li><code>char const * componentName( vk::Format format, uint8_t component );</code> Gets the name of this component as a c-string.</li>
<li><code>char const * componentNumericFormat( vk::Format format, uint8_t component );</code> Gets the numeric format of this component as a c-string.</li>
<li><code>uint8_t componentPlaneIndex( vk::Format format, uint8_t component );</code> Gets the plane index, this component lies in.</li>
<li><code>uint8_t planeCount( vk::Format format );</code> Gets the number of image planes of this format.</li>
<li><code><a class="el" href="namespacevk.html#aeed52badda6494849010ed8cb30bd530">vk::Format</a> planeCompatibleFormat( vk::Format format, uint8_t plane );</code> Gets a single-plane format compatible with this plane.</li>
<li><code>uint8_t planeHeightDivisor( vk::Format format, uint8_t plane );</code> Gets the relative height of this plane. A value of k means that this plane is 1/k the height of the overall format.</li>
<li><code>uint8_t planeWidthDivisor( vk::Format format, uint8_t plane );</code> Gets the relative width of this plane. A value of k means that this plane is 1/k the width of the overall format.</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
Hashing Vulkan types</h2>
<p>With the additional header <code><a class="el" href="vulkan__hash_8hpp.html">vulkan_hash.hpp</a></code>, you get specializations of <code>std::hash</code> for the handle wrapper classes and, with C++14, for the structure wrappers. With <code>VULKAN_HPP_HASH_COMBINE</code>, you can define your own hash combining algorithm for the structure elements.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Extension Inspection</h2>
<p>With the additional header <code><a class="el" href="vulkan__extension__inspection_8hpp.html">vulkan_extension_inspection.hpp</a></code>, some functions to inspect extensions are provided. With C++20 and above, some of those functions are marked as <code>constexpr</code>, that is with appropriate arguments, they are resolved by the compiler. Each extension is identified by a string holding its name. Note that there exists a define with that name for each extension. Some functions might provide information that depends on the vulkan version. As all functions here work solely on strings, the vulkan versions are encoded by a string beginning with "VK_VERSION_", followed by the major and the minor version, separated by an undersore, like this: "VK_VERSION_1_0".</p><ul>
<li><code>std::set&lt;std::string&gt; const &amp; <a class="el" href="namespacevk.html#aa402d705d87154fb9f5b9b6e1dc31599">getDeviceExtensions()</a>;</code> Gets all device extensions specified for the current platform. Note, that not all of them might be supported by the actual devices.</li>
<li><code>std::set&lt;std::string&gt; const &amp; <a class="el" href="namespacevk.html#ab441d3dee1cd340a0cf5af5f19263de7">getInstanceExtensions()</a>;</code> Gets all instance extensions specified for the current platform. Note, that not all of them might be supported by the actual instances.</li>
<li><code>std::map&lt;std::string, std::string&gt; const &amp; <a class="el" href="namespacevk.html#a2cbaa0b836289cf4e7ac2d2e6e41124d">getDeprecatedExtensions()</a>;</code> Gets a map of all deprecated extensions to the extension or vulkan version that is supposed to replace that functionality.</li>
<li><code>std::map&lt;std::string, std::vector&lt;std::vector&lt;std::string&gt;&gt;&gt; const &amp; getExtensionDepends( std::string const &amp; extension );</code> Some extensions depends on other extensions. That dependencies might differ for different vulkan versions, and there might be different sets of dependencies for the very same vulkan version. This function gets a vector of vectors of extensions per vulkan version that the given extension depends on.</li>
<li><code>std::pair&lt;bool, std::vector&lt;std::vector&lt;std::string&gt;&gt; const &amp;&gt; getExtensionDepends( std::string const &amp; version, std::string const &amp; extension );</code> The <code>first</code> member of the returned <code>std::pair</code> is true, if the given extension is specified for the given vulkan version, otherwise <code>false</code>. The <code>second</code> member of the returned <code>std::pair</code> is a vector of vectors of extensions, listing the separate sets of extensions the given extension depends on for the given vulkan version.</li>
<li><code>std::map&lt;std::string, std::string&gt; const &amp; <a class="el" href="namespacevk.html#a6b5ded2cea98554fc49af458ad864c06">getObsoletedExtensions()</a>;</code> Gets a map of all obsoleted extensions to the extension or vulkan version that has obsoleted that extension.</li>
<li><code>std::map&lt;std::string, std::string&gt; const &amp; <a class="el" href="namespacevk.html#ab79bbee34c03047565e6481d5270df95">getPromotedExtensions()</a>;</code> Gets a map of all extensions that got promoted to another extension or to a vulkan version to that extension of vulkan version.</li>
<li><code>VULKAN_HPP_CONSTEXPR_20 std::string getExtensionDeprecatedBy( std::string const &amp; extension );</code> Gets the extension or vulkan version the given extension is deprecated by.</li>
<li><code>VULKAN_HPP_CONSTEXPR_20 std::string getExtensionObsoletedBy( std::string const &amp; extension );</code> Gets the extension or vulkan version the given extension is obsoleted by.</li>
<li><code>VULKAN_HPP_CONSTEXPR_20 std::string getExtensionPromotedTo( std::string const &amp; extension );</code> Gets the extension or vulkan version the given extension is promoted to.</li>
<li><code>VULKAN_HPP_CONSTEXPR_20 bool isDeprecatedExtension( std::string const &amp; extension );</code> Returns <code>true</code> if the given extension is deprecated by some other extension or vulkan version.</li>
<li><code>VULKAN_HPP_CONSTEXPR_20 bool isDeviceExtension( std::string const &amp; extension );</code> Returns <code>true</code> if the given extension is a device extension.</li>
<li><code>VULKAN_HPP_CONSTEXPR_20 bool isInstanceExtension( std::string const &amp; extension );</code> Returns <code>true</code> if the given extension is an instance extension.</li>
<li><code>VULKAN_HPP_CONSTEXPR_20 bool isObsoletedExtension( std::string const &amp; extension );</code> Returns <code>true</code> if the given extension is obsoleted by some other extension or vulkan version.</li>
<li><code>VULKAN_HPP_CONSTEXPR_20 bool isPromotedExtension( std::string const &amp; extension );</code> Returns <code>true</code> if the given extension is promoted to some other extension or vulkan version.</li>
</ul>
<h2><a class="anchor" id="autotoc_md31"></a>
C++20 named module</h2>
<blockquote class="doxtable">
<p>[!WARNING] The current version of Microsoft Visual Studio 2022 is not able to handle the <a class="el" href="vulkan_8cppm.html">vulkan.cppm</a> module. A bug is filed (<a href="https://developercommunity.visualstudio.com/t/On-building-a-C20-module:-fatal&ndash;error/10469799#T-ND10485943">https://developercommunity.visualstudio.com/t/On-building-a-C20-module:-fatal&amp;ndash;error/10469799#T-ND10485943</a>). You can at least use this feature if you don't need or want to use <code><a class="el" href="classvk_1_1UniqueHandle.html">vk::UniqueHandle</a></code> or <code>vk::SharedHandle</code> by defining <code>VULKAN_HPP_NO_SMART_HANDLE</code>. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md32"></a>
Overview</h3>
<p>Vulkan-Hpp provides a <a href="https://en.cppreference.com/w/cpp/language/modules">C++ named module</a>, <code>vulkan_hpp</code> in <a href="vulkan/vulkan.cppm"><code>vulkan.cppm</code></a>. C++ modules are intended to supersede header files. Modules have potential to drastically improve compilation times for large projects, as declarations and definitions may be easily shared across translation units without repeatedly parsing headers. Vulkan-Hpp has some extremely long headers (e.g. <a href="vulkan/vulkan_structs.hpp"><code>vulkan_structs.hpp</code></a>), and the C++ module is likely to shorten compile times for projects currently using it.</p>
<h3><a class="anchor" id="autotoc_md33"></a>
Compiler support</h3>
<p>This feature requires a recent compiler with complete C++20 support:</p>
<ul>
<li>Visual Studio 2019 16.10 or later (providing <code>cl.exe</code> 19.28 or later)</li>
<li>Clang 15.0.0 or later</li>
</ul>
<p>If you intend to use CMake's C++ module support (and possibly Ninja), then more recent tools are required:</p>
<ul>
<li>Visual Studio 2022 17.4 or later (providing <code>cl.exe</code> 19.34 or later)</li>
<li>Clang 17.0.0 or later</li>
<li>GCC 14.0 or later</li>
<li>CMake 3.28 or later</li>
<li>Ninja 1.10.2 or later</li>
</ul>
<blockquote class="doxtable">
<p>[!WARNING] The Vulkan-Hpp C++ named module is still experimental. Some suggested ways to use it in your projects are below. The long-term goal is to submit patches to the CMake <a href="https://cmake.org/cmake/help/latest/module/FindVulkan.html"><code>FindVulkan</code></a> module so that users may transparently configure the named module, without needing to declare it as an additional library in consumer CMake code. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md34"></a>
Usage with CMake</h4>
<p>CMake is recommended for use with the Vulkan-Hpp named module, as it provides a convenient platform-agnostic way to configure your project. CMake version 3.28 or later is required to support C++ modules. Refer to the <a href="https://cmake.org/cmake/help/latest/manual/cmake-cxxmodules.7.html">CMake documentation</a> on the topic.</p>
<p>CMake provides the <a href="https://cmake.org/cmake/help/latest/module/FindVulkan.html">FindVulkan module</a>, which may be used to source the Vulkan SDK and Vulkan headers on your system.</p>
<div class="fragment"><div class="line"># find Vulkan SDK</div>
<div class="line">find_package( Vulkan REQUIRED )</div>
<div class="line"> </div>
<div class="line"># Require Vulkan version  1.3.256 (earliest version when the Vulkan module was available)</div>
<div class="line">if( ${Vulkan_VERSION} VERSION_LESS &quot;1.3.256&quot; )</div>
<div class="line">  message( FATAL_ERROR &quot;Minimum required Vulkan version for C++ modules is 1.3.256. &quot;</div>
<div class="line">           &quot;Found ${Vulkan_VERSION}.&quot;</div>
<div class="line">  )</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line"># set up Vulkan C++ module as a library</div>
<div class="line">add_library( VulkanHppModule )</div>
<div class="line">target_sources( VulkanHppModule PRIVATE</div>
<div class="line">  FILE_SET CXX_MODULES</div>
<div class="line">  BASE_DIRS ${Vulkan_INCLUDE_DIR}</div>
<div class="line">  FILES ${Vulkan_INCLUDE_DIR}/vulkan/vulkan.cppm</div>
<div class="line">)</div>
<div class="line">target_compile_features( VulkanHppModule PUBLIC cxx_std_20 )</div>
<div class="line">target_link_libraries( VulkanHppModule PUBLIC Vulkan::Vulkan )</div>
<div class="line"> </div>
<div class="line"># link Vulkan C++ module into your project</div>
<div class="line">add_executable( YourProject main.cpp )</div>
<div class="line">target_link_libraries( YourProject PRIVATE VulkanHppModule )</div>
</div><!-- fragment --><p>Configuring the named module is straightforward; add any required Vulkan-Hpp feature macros (listed in <a href="#configuration-options">Configuration Options</a>) to <code>target_compile_definitions</code>. For instance:</p>
<div class="fragment"><div class="line"># Disable exceptions, disable smart handles, disable constructors</div>
<div class="line">target_compile_definitions( VulkanHppModule PRIVATE</div>
<div class="line">  VULKAN_HPP_NO_EXCEPTIONS</div>
<div class="line">  VULKAN_HPP_NO_SMART_HANDLE</div>
<div class="line">  VULKAN_HPP_NO_CONSTRUCTORS</div>
<div class="line">)</div>
</div><!-- fragment --><p>It is important to have <code>VULKAN_HPP_DISPATCH_LOADER_DYNAMIC</code> defined equally for both the module and an importing project. To use the <a href="#extensions--per-device-function-pointers">dynamic dispatcher</a>, set it to <code>1</code>; otherwise, leave it undefined or set it to <code>0</code>. In CMake, do this in a single line with <code>target_compile_definitions</code> and the <code>PUBLIC</code> scope:</p>
<div class="fragment"><div class="line">target_compile_definitions( VulkanHppModule PUBLIC</div>
<div class="line">  VULKAN_HPP_DISPATCH_LOADER_DYNAMIC=1</div>
<div class="line">)</div>
<div class="line"># ...</div>
<div class="line">target_link_libraries( YourProject PRIVATE VulkanHppModule )</div>
</div><!-- fragment --><p>Furthermore, you may also prefer linking <code>VulkanHppModule</code> to just the <code>Vulkan::Headers</code> target with the <code>PUBLIC</code> scope instead of <code>Vulkan::Vulkan</code>, so that the <code>vulkan-1</code> library is not linked in, and the Vulkan headers are available to your consuming project, as detailed further below.</p>
<div class="fragment"><div class="line">target_link_libraries( VulkanHppModule PUBLIC Vulkan::Headers )</div>
</div><!-- fragment --><p>Finally, supply the macro <code>VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE</code> exactly once in your source code, just as in the non-module case. In order to have that macro available, include <code>&lt;<a class="el" href="vulkan__hpp__macros_8hpp.html">vulkan/vulkan_hpp_macros.hpp</a>&gt;</code>, a lightweight header providing all Vulkan-Hpp related macros and defines. And as explained above, you need to initialize that dispatcher in two or three steps:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> <a class="code" href="vulkan_8cppm.html#a7d2734f83429c79adce2f3a29ae996bd">vulkan_hpp</a>;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vulkan__hpp__macros_8hpp.html">vulkan/vulkan_hpp_macros.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if VULKAN_HPP_DISPATCH_LOADER_DYNAMIC == 1</span></div>
<div class="line"><a class="code" href="vulkan__hpp__macros_8hpp.html#ab39413d43e90fc4d41659ee9a417d820">VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE</a></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="01__InitInstance_8cpp.html#a2c3f6775325c30275d11c6abee2db6a0">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* <span class="keyword">const</span> argv[]) -&gt; <span class="keywordtype">int</span></div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if ( VULKAN_HPP_DISPATCH_LOADER_DYNAMIC == 1 )</span></div>
<div class="line">    <span class="comment">// initialize minimal set of function pointers</span></div>
<div class="line">    <a class="code" href="vulkan__hpp__macros_8hpp.html#a2a931d9beee1ecf03437ad812f4e5510">VULKAN_HPP_DEFAULT_DISPATCHER</a>.init();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> appInfo = <a class="code" href="structvk_1_1ApplicationInfo.html">vk::ApplicationInfo</a>( <span class="stringliteral">&quot;My App&quot;</span>, 1, <span class="stringliteral">&quot;My Engine&quot;</span>, 1, <a class="code" href="namespacevk.html#aa725355d8096dc21e8e21e5b28790d31">vk::makeApiVersion</a>( 1, 0, 0, 0 ) );</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="ttc" id="a01__InitInstance_8cpp_html_a2c3f6775325c30275d11c6abee2db6a0"><div class="ttname"><a href="01__InitInstance_8cpp.html#a2c3f6775325c30275d11c6abee2db6a0">main</a></div><div class="ttdeci">int main(int, char **)</div><div class="ttdef"><b>Definition:</b> 01_InitInstance.cpp:24</div></div>
<div class="ttc" id="anamespacevk_html_aa725355d8096dc21e8e21e5b28790d31"><div class="ttname"><a href="namespacevk.html#aa725355d8096dc21e8e21e5b28790d31">vk::makeApiVersion</a></div><div class="ttdeci">VULKAN_HPP_CONSTEXPR uint32_t makeApiVersion(T const variant, T const major, T const minor, T const patch)</div><div class="ttdef"><b>Definition:</b> vulkan.hpp:6867</div></div>
<div class="ttc" id="avulkan_8cppm_html_a7d2734f83429c79adce2f3a29ae996bd"><div class="ttname"><a href="vulkan_8cppm.html#a7d2734f83429c79adce2f3a29ae996bd">vulkan_hpp</a></div><div class="ttdeci">export module vulkan_hpp</div><div class="ttdef"><b>Definition:</b> vulkan.cppm:20</div></div>
<div class="ttc" id="avulkan__hpp__macros_8hpp_html"><div class="ttname"><a href="vulkan__hpp__macros_8hpp.html">vulkan_hpp_macros.hpp</a></div></div>
<div class="ttc" id="avulkan__hpp__macros_8hpp_html_ab39413d43e90fc4d41659ee9a417d820"><div class="ttname"><a href="vulkan__hpp__macros_8hpp.html#ab39413d43e90fc4d41659ee9a417d820">VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE</a></div><div class="ttdeci">#define VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE</div><div class="ttdef"><b>Definition:</b> vulkan_hpp_macros.hpp:258</div></div>
</div><!-- fragment --><p>An example is provided in <a href="tests/Cpp20Modules/Cpp20Modules.cpp"><code>tests/Cpp20Modules/Cpp20Modules.cpp</code></a>.</p>
<p>Finally, you can configure and build your project as usual. Note that CMake currently only supports the Ninja and Visual Studio generators for C++ modules.</p>
<h4><a class="anchor" id="autotoc_md35"></a>
Command-line usage</h4>
<p>If you want to use the Vulkan-Hpp C++ module without CMake, you must first pre-compile it, and then import it into your project. You will also need to define any macros that control various features of Vulkan-Hpp, such as <code>VULKAN_HPP_NO_EXCEPTIONS</code> and <code>VULKAN_HPP_NO_SMART_HANDLE</code>. Different compilers have different command-lines for module pre-compilation; however, for initial use, some examples are provided below, assuming the same <code>main.cpp</code> consumer as above.</p>
<p>For MSVC, source <code>vcvars64.bat</code> or use a Developer Command Prompt/Developer PowerShell instance, and run the following:</p>
<div class="fragment"><div class="line">cl.exe /std:c++20 /interface /TP &lt;path-to-vulkan-hpp&gt;\vulkan.cppm</div>
<div class="line">cl.exe /std:c++20 /reference vulkan=vulkan.ifc main.cpp vulkan.obj</div>
<div class="line">.\main.exe</div>
</div><!-- fragment --><p>For Clang, run the following:</p>
<div class="fragment"><div class="line">clang++ -std=c++20 &lt;path-to-vulkan-hpp&gt;/vulkan.cppm -precompile -o vulkan.pcm</div>
<div class="line">clang++ -std=c++20 -fprebuilt-module-path=. main.cpp vulkan.pcm -o main</div>
<div class="line">./main</div>
</div><!-- fragment --><p>More information about module compilation may be found at the respective compiler's documentation:</p>
<ul>
<li><a href="https://learn.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-170">MSVC</a></li>
<li><a href="https://clang.llvm.org/docs/StandardCPlusPlusModules.html">Clang</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md36"></a>
Samples and Tests</h2>
<p>When you configure your project using CMake, you can enable SAMPLES_BUILD to add some sample projects to your solution. Most of them are ports from the LunarG samples, but there are some more, like CreateDebugUtilsMessenger, InstanceVersion, PhysicalDeviceDisplayProperties, PhysicalDeviceExtensions, PhysicalDeviceFeatures, PhysicalDeviceGroups, PhysicalDeviceMemoryProperties, PhysicalDeviceProperties, PhysicalDeviceQueueFamilyProperties, and RayTracing. All those samples should just compile and run. When you configure your project using CMake, you can enable TESTS_BUILD to add some test projects to your solution. Those tests are just compilation tests and are not required to run.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Compile time issues</h2>
<p>As <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> is pretty big, some compilers might need some time to digest all that stuff. In order to potentially reduce the time needed to compile that header, a couple of defines will be introduced, that allow you to hide certain features. Whenever you don't need that corresponding feature, defining that value might improve your compile time. Currently, there are just a couple of such defines:</p><ul>
<li><code>VULKAN_HPP_NO_SPACESHIP_OPERATOR</code>, which removes the spaceship operator on structures (available with C++20)</li>
<li><code>VULKAN_HPP_NO_TO_STRING</code>, which removes the various <a class="el" href="namespacevk.html#a59260c409414530accf18c67b6c8690d">vk::to_string</a> functions on enums and bitmasks.</li>
<li><code>VULKAN_HPP_USE_REFLECT</code>, this one needs to be defined to use the reflection function on structures. It's very slow to compile, though!</li>
</ul>
<h1><a class="anchor" id="autotoc_md38"></a>
Configuration Options</h1>
<p>There are a couple of defines you can use to control the feature set and behaviour of <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>:</p>
<h3><a class="anchor" id="autotoc_md39"></a>
VULKAN_HPP_ASSERT</h3>
<p>At various places in <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> an assertion statement is used. By default, the standard assert funtions from <code>&lt;cassert&gt;</code> is called. By defining <code>VULKAN_HPP_ASSERT</code> before including <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>, you can change that to any function with the very same interface.</p>
<h3><a class="anchor" id="autotoc_md40"></a>
VULKAN_HPP_ASSERT_ON_RESULT</h3>
<p>If there are no exceptions enabled (see <code>VULKAN_HPP_NO_EXCEPTIONS</code>), an assertion statement checks for a valid success code returned from every vulkan call. By default, this is the very same assert function as defined by <code>VULKAN_HPP_ASSERT</code>, but by defining <code>VULKAN_HPP_ASSERT_ON_RESULT</code> you can replace just those assertions with your own function, using the very same interface.</p>
<h3><a class="anchor" id="autotoc_md41"></a>
VULKAN_HPP_DEFAULT_DISPATCHER</h3>
<p>Every vk-function gets a Dispatcher as its very last argument, which defaults to <code>VULKAN_HPP_DEFAULT_DISPATCHER</code>. If <code>VULKAN_HPP_DISPATCH_LOADER_DYNAMIC</code> is defined to be 1, it is <code>defaultDispatchLoaderDynamic</code>. This in turn is the dispatcher instance, which is defined by <code>VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE</code>, which has to be used exactly once in your sources. If, on the other hand, <code>VULKAN_HPP_DISPATCH_LOADER_DYNAMIC</code> is defined to something different from 1, <code>VULKAN_HPP_DEFAULT_DISPATCHER</code> is set to be <code>DispatchLoaderStatic()</code>. You can use your own default dispatcher by setting <code>VULKAN_HPP_DEFAULT_DISPATCHER</code> to an object that provides the same API. If you explicitly set <code>VULKAN_HPP_DEFAULT_DISPATCHER</code>, you need to set <code>VULKAN_HPP_DEFAULT_DISPATCHER_TYPE</code> accordingly as well.</p>
<h3><a class="anchor" id="autotoc_md42"></a>
VULKAN_HPP_DEFAULT_DISPATCHER_TYPE</h3>
<p>This names the default dispatcher type, as specified by <code>VULKAN_HPP_DEFAULT_DISPATCHER</code>. Per default, it is DispatchLoaderDynamic or DispatchLoaderStatic, depending on <code>VULKAN_HPP_DISPATCH_LOADER_DYNAMIC</code> being 1 or not 1, respectively. If you explicitly set <code>VULKAN_HPP_DEFAULT_DISPATCHER</code>, you need to set <code>VULKAN_HPP_DEFAULT_DISPATCHER_TYPE</code> accordingly as well.</p>
<h3><a class="anchor" id="autotoc_md43"></a>
VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE</h3>
<p>If you have not defined your own <code>VULKAN_HPP_DEFAULT_DISPATCHER</code>, and have <code>VULKAN_HPP_DISPATCH_LOADER_DYNAMIC</code> defined to be 1 (the default), you need to have the macro <code>VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE</code> exactly once in any of your source files to provide storage for that default dispatcher. <code>VULKAN_HPP_STORAGE_API</code> then controls the import/export status of that default dispatcher.</p>
<h3><a class="anchor" id="autotoc_md44"></a>
VULKAN_HPP_DISABLE_ENHANCED_MODE</h3>
<p>When this is defined before including <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>, you essentially disable all enhanced functionality. All you then get is</p><ul>
<li>improved compile time error detection, via scoped enums;</li>
<li>usage of the helper class <code><a class="el" href="classvk_1_1Flags.html">vk::Flags</a></code> for bitmasks;</li>
<li>wrapper structs for all vulkan structs providing default initialization;</li>
<li>the helper class <code><a class="el" href="classvk_1_1StructureChain.html">vk::StructureChain</a></code> for compile-time construction of structure chains.</li>
</ul>
<p>If this is not defined, you additionally get</p><ul>
<li>enhanced versions of the commands (consuming <code><a class="el" href="classvk_1_1ArrayProxy.html">vk::ArrayProxy</a>&lt;&gt;</code>, simplifying handling of array data; returning requested data; throwing exceptions on errors (as long as <code>VULKAN_HPP_NO_EXCEPTIONS</code> is not defined);</li>
<li>enhanced structure constructors (as long as <code>VULKAN_HPP_NO_STRUCT_CONSTRUCTORS</code> is not defined) (consuming <code><a class="el" href="classvk_1_1ArrayProxyNoTemporaries.html">vk::ArrayProxyNoTemporaries</a>&lt;&gt;</code>);</li>
<li>enhanced setter functions on some members of structs (consuming <code><a class="el" href="classvk_1_1ArrayProxyNoTemporaries.html">vk::ArrayProxyNoTemporaries</a>&lt;&gt;</code>);</li>
<li>the helper classes <code><a class="el" href="classvk_1_1ArrayProxy.html">vk::ArrayProxy</a>&lt;&gt;</code> and <code><a class="el" href="classvk_1_1ArrayProxyNoTemporaries.html">vk::ArrayProxyNoTemporaries</a>&lt;&gt;</code></li>
<li>all the RAII-stuff in <a class="el" href="vulkan__raii_8hpp.html">vulkan_raii.hpp</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md45"></a>
VULKAN_HPP_DISPATCH_LOADER_DYNAMIC</h3>
<p>This either selects the dynamic (when it's 1) or the static (when it's not 1) DispatchLoader as the default one, as long as it's not explicitly specified by <code>VULKAN_HPP_DEFAULT_DISPATCHER</code>. By default, this is defined to be 1 if <code>VK_NO_PROTOTYPES</code> is defined, otherwise 0.</p>
<h3><a class="anchor" id="autotoc_md46"></a>
VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL</h3>
<p>By default, a little helper class <code>DynamicLoader</code> is used to dynamically load the vulkan library. If you set it to something different than 1 before including <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>, this helper is not available, and you need to explicitly provide your own loader type for the function <code>DispatchLoaderDynamic::init()</code>.</p>
<h3><a class="anchor" id="autotoc_md47"></a>
VULKAN_HPP_EXPECTED</h3>
<p>When this is not externally defined and VULKAN_HPP_CPP_VERSION is at least 23, VULKAN_HPP_EXPECTED is defined to be std::expected, and VULKAN_HPP_UNEXPECTED is defined to be std::unexpected.</p>
<h3><a class="anchor" id="autotoc_md48"></a>
VULKAN_HPP_FLAGS_MASK_TYPE_AS_PUBLIC</h3>
<p>By default, the member <code>m_mask</code> of the <code>Flags</code> template class is private. This is to prevent accidentally setting a <code>Flags</code> with some inappropriate value. But it also prevents using a <code>Flags</code>, or a structure holding a <code>Flags</code>, to be used as a non-type template parameter. If you really need that functionality, and accept the reduced security, you can use this define to change the access specifier for m_mask from private to public, which allows using a <code>Flags</code> as a non-type template parameter.</p>
<h3><a class="anchor" id="autotoc_md49"></a>
VULKAN_HPP_HASH_COMBINE</h3>
<p>This define can be used to specify your own hash combiner function. In order to determine the hash of a vk-structure, the hashes of the members of that struct are to be combined. This is done by this define, which by default is identical to what the function <code>boost::hash_combine()</code> does. It gets the type of the to-be-combined value, the seed, which is the combined value up to that point, and finally the to-be-combined value. This hash calculation determines a "shallow" hash, as it takes the hashes of any pointer in a structure, and not the hash of a pointed-to value.</p>
<h3><a class="anchor" id="autotoc_md50"></a>
VULKAN_HPP_INLINE</h3>
<p>This is set to be the compiler-dependent attribute used to mark functions as inline. If your compiler happens to need some different attribute, you can set this define accordingly before including <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>.</p>
<h3><a class="anchor" id="autotoc_md51"></a>
VULKAN_HPP_NAMESPACE</h3>
<p>By default, the namespace used with <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> is <code>vk</code>. By defining <code>VULKAN_HPP_NAMESPACE</code> before including <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>, you can adjust this.</p>
<h3><a class="anchor" id="autotoc_md52"></a>
VULKAN_HPP_NO_TO_STRING</h3>
<p>By default, the file <a class="el" href="vulkan__to__string_8hpp.html">vulkan_to_string.hpp</a> is included by <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> and provides functions <code><a class="el" href="namespacevk.html#a59260c409414530accf18c67b6c8690d">vk::to_string</a></code> for enums and bitmasks. If you don't need those functions, you can define VULKAN_HPP_NO_TO_STRING to prevent that inclusion. If you have certain files where you want to use those functions nevertheless, you can explicitly include <a class="el" href="vulkan__to__string_8hpp.html">vulkan_to_string.hpp</a> there.</p>
<h3><a class="anchor" id="autotoc_md53"></a>
VULKAN_HPP_NO_CONSTRUCTORS</h3>
<p>With C++20, designated initializers are available. Their use requires the absence of any user-defined constructors. Define <code>VULKAN_HPP_NO_CONSTRUCTORS</code> to remove constructors from structs and unions.</p>
<h3><a class="anchor" id="autotoc_md54"></a>
VULKAN_HPP_NO_EXCEPTIONS</h3>
<p>When a vulkan function returns an error code that is not specified to be a success code, an exception is thrown unless <code>VULKAN_HPP_NO_EXCEPTIONS</code> is defined before including <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>.</p>
<h3><a class="anchor" id="autotoc_md55"></a>
VULKAN_HPP_NO_NODISCARD_WARNINGS</h3>
<p>With C++17, all <code>vk</code>-functions returning something are declared with the attribute <code>[[nodiscard]]</code>. This can be removed by defining <code>VULKAN_HPP_NO_NODISCARD_WARNINGS</code> before including <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>.</p>
<h3><a class="anchor" id="autotoc_md56"></a>
VULKAN_HPP_NO_SETTERS</h3>
<p>By defining <code>VULKAN_HPP_NO_SETTERS</code>before including <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>, setter member functions will not be available within structs and unions. Modifying their data members will then only be possible via direct assignment.</p>
<h3><a class="anchor" id="autotoc_md57"></a>
VULKAN_HPP_NO_SMART_HANDLE</h3>
<p>By defining <code>VULKAN_HPP_NO_SMART_HANDLE</code> before including <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a>, the helper class <code>UniqueHandle</code> and all the unique handle types are not available.</p>
<h3><a class="anchor" id="autotoc_md58"></a>
VULKAN_HPP_NO_SPACESHIP_OPERATOR</h3>
<p>With C++20, the so-called spaceship-operator <code>&lt;=&gt;</code> is introduced. If that operator is supported, all the structs and classes in <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> use the default implementation of it. As currently some implementations of this operator are very slow, and others seem to be incomplete, by defining <code>VULKAN_HPP_NO_SPACESHIP_OPERATOR</code> before including <a class="el" href="vulkan_8hpp.html">vulkan.hpp</a> you can remove that operator from those structs and classes.</p>
<h3><a class="anchor" id="autotoc_md59"></a>
VULKAN_HPP_NO_WIN32_PROTOTYPES</h3>
<p>By default, if <code>VULKAN_HPP_ENABLE_DYNAMIC_LOADER_TOOL</code> is enabled on Win32, <code><a class="el" href="vulkan_8hpp.html">vulkan.hpp</a></code> declares <code>HINSTANCE</code>, <code>LoadLibraryA</code>, and other required symbols. It could cause conflicts with the <code>Windows.h</code> alternatives, such as <code>WindowsHModular</code>. With this define, you can disable these declarations, but you will have to declare them before the <code><a class="el" href="vulkan_8hpp.html">vulkan.hpp</a></code> is included.</p>
<h3><a class="anchor" id="autotoc_md60"></a>
VULKAN_HPP_RAII_NO_EXCEPTIONS</h3>
<p>If both, VULKAN_HPP_NO_EXCEPTIONS and VULKAN_HPP_EXPECTED are defined, the <a class="el" href="namespacevk_1_1raii.html">vk::raii</a>-classes don't throw exceptions. That is, the actual constructors are not available, but the creation-functions must be used. For more details have a look at the <a class="el" href="vk__raii__ProgrammingGuide_8md.html">vk_raii_ProgrammingGuide.md</a>.</p>
<h3><a class="anchor" id="autotoc_md61"></a>
VULKAN_HPP_SMART_HANDLE_IMPLICIT_CAST</h3>
<p>Even though the <code>vk::UniqueHandles</code> and the <code>vk::SharedHandles</code> are semantically close to pointers, an implicit cast operator to the underlying <code>vk::Handle</code> might be handy. You can add that implicit cast operator by defining <code>VULKAN_HPP_SMART_HANDLE_IMPLICIT_CAST</code>.</p>
<h3><a class="anchor" id="autotoc_md62"></a>
VULKAN_HPP_STORAGE_API</h3>
<p>With this define you can specify whether the <code>DispatchLoaderDynamic</code> is imported or exported (see <code>VULKAN_HPP_DEFAULT_DISPATCH_LOADER_DYNAMIC_STORAGE</code>). If <code>VULKAN_HPP_STORAGE_API</code> is not defined externally, and <code>VULKAN_HPP_STORAGE_SHARED</code> is defined, depending on the <code>VULKAN_HPP_STORAGE_SHARED_EXPORT</code> being defined, <code>VULKAN_HPP_STORAGE_API</code> is either set to <code>__declspec( dllexport )</code> (for MSVC) / <code>__attribute__( ( visibility( "default" ) ) )</code> (for gcc or clang) or <code>__declspec( dllimport )</code> (for MSVC), respectively. For other compilers, you might specify the corresponding storage by defining <code>VULKAN_HPP_STORAGE_API</code> on your own.</p>
<h3><a class="anchor" id="autotoc_md63"></a>
VULKAN_HPP_TYPESAFE_CONVERSION</h3>
<p>32-bit vulkan is not typesafe for non-dispatchable handles, so we don't allow copy constructors on this platform by default. To enable this feature on 32-bit platforms define <code>VULKAN_HPP_TYPESAFE_CONVERSION</code>.</p>
<h3><a class="anchor" id="autotoc_md64"></a>
VULKAN_HPP_UNEXPECTED</h3>
<p>See <code>VULKAN_HPP_EXPECTED</code>.</p>
<h3><a class="anchor" id="autotoc_md65"></a>
VULKAN_HPP_USE_REFLECT</h3>
<p>With this define you can include a reflection mechanism on the vk-structures. It adds a function <code>reflect</code> that returns a tuple-version of the structure. That tuple then could easily be iterated. But at least for now, that feature takes lots of compile-time resources, so currently it is recommended to enable that feature only if you're willing to pay that price.</p>
<h1><a class="anchor" id="autotoc_md66"></a>
See Also</h1>
<p>Feel free to submit a PR to add to this list.</p>
<ul>
<li><a href="https://github.com/jherico/vulkan">Examples</a> A port of Sascha Willems <a href="https://github.com/SaschaWillems/Vulkan">examples</a> to Vulkan-Hpp</li>
<li><a href="https://github.com/andy-thomason/Vookoo/">Vookoo</a> Stateful helper classes for Vulkan-Hpp, <a href="https://accu.org/journals/overload/25/139/overload139.pdf#page=14">Introduction Article</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md67"></a>
License</h1>
<p>Copyright 2015-2020 The Khronos Group Inc.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
